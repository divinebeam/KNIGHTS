import py_sys;
sys.setrecursionlimit(2000);

// @bm CONSTANTS
const L_ANYWHERE = $L("Anywhere");
const L_MAIN = $L("main");
const L_0X0 = $L("0x0");
const L_1X1 = $L("1x1");
const L_3X3 = $L("3x3");
const L_4X4 = $L("4x4");
const L_10X10 = $L("10x10");
const L_16X16 = $L("16x16");
const L_PLAYER = [4, 5, 6, 7, 8, 9];
const L_MOUSE = [16, 17, 18, 19, 20, 21];
const L_CHECK = $L("check");
const L_HEIGHT0 = $L("height0");
const L_HEIGHT1 = $L("height1");
const L_HEIGHT2 = $L("height2");
const L_UNITBUFFER = $L("unit_buffer");

const U_HERO = [61, 62, 64, 12, 60, 86];
const U_CHIMERA = 37;
const U_HILL_SPINT = 38;
const U_GUARDIAN_ANGEL = 68;
const U_TWISTED_KNIGHT = 51;
const U_LOST_KNIGHT = 74;
const U_ANANSI = 40;
const U_ANY = 229;
const U_KAKARU = 94;
const U_SCOURGE = 47;
const U_WEAPON = 129;
const U_ARMOR = 219;
const U_UTILITY = 128;
const U_CONSUMABLE = 227;
const U_MARKER = 7; // P9 = UTILITY, P10 = WEAPON, P11 = ARMOR, P12 = SPECIAL
const U_EXPERIENCE = 220;
const U_CHECKHEIGHT = 9;
const U_CHECK_TERRAIN_COLLIDER = 54; // 42
const U_PATHABLE = 0;
const U_LIFEPICKUP = 106;
const U_HARVEST_MARKER = 107; // P9 = GARTLE, P10 = HOOD, P11 = TARGUS
const U_TORCH = 27; // 27

const NPC_GUARDIAN_ANGEL = 1;
const NPC_CETUS = 2;

const ORDER_HOLD = 107;
const ORDER_PATROL = 152;

const ISCRIPT_NORMAL = 281;
const ISCRIPT_FAST = 286;
const ISCRIPT_LONGFAST = 392;
const ISCRIPT_GAUSS_RIFLE_HIT = 278;

const IMAGE_ZERG_AIR_DEATH_SMALL = 59;
const IMAGE_ZERG_AIR_DEATH_LARGE = 58;
const IMAGE_PLAGUE_CLOUD = 387;
const IMAGE_HALLUC_DEATH1 = 557;
const IMAGE_EXPL_BLUE_SMALL = 213;
const IMAGE_SCOURGE_ATTACK = 4;
const IMAGE_LONGBOLT_TRAIL = 422;
const IMAGE_FRAG_GRENADE_HIT = 440;
const IMAGE_LIGHTNING_STORM = 525;
const IMAGE_LIGHTNING0 = 550;
const IMAGE_LIGHTNING1 = 551;
const IMAGE_LIGHTNING2 = 552;
const IMAGE_LIGHTNING3 = 553;
const IMAGE_NUKE_DOT = 233;
const IMAGE_PHOTON_BLASTERS = 519;
const IMAGE_PARTICLE_BEAM = 520;
const IMAGE_SCARAB_MISSILE = 443;
const IMAGE_ZEALOT_DEATH = 153;
const IMAGE_BURST_LASER = 447;
const IMAGE_NEUTRON = 964;
const IMAGE_GAUSS_RIFLE_HIT = 527;
const IMAGE_NUKE_DEATH = 428;
const IMAGE_VENOM_HIT = 508;
const IMAGE_GEYSER_SMOKE1 = 430;
const IMAGE_GEYSER_SMOKE2 = 431;
const IMAGE_GEYSER_SMOKE3 = 432;
const IMAGE_GEYSER_SMOKE4 = 433;
const IMAGE_GEYSER_SMOKE5 = 434;
const IMAGE_SPORES_OVERLAY = 514;
const IMAGE_GREEN_FLAME0 = 435;
const IMAGE_GREEN_FLAME1 = 436;
const IMAGE_GREEN_FLAME2 = 437;
const IMAGE_GREEN_FLAME3 = 438;
const IMAGE_GREEN_FLAME4 = 439;
const IMAGE_ORANGE_FLAME_SMALL0 = 452;

const MAX_PLAYERS = 6;
const FULL_DAY_LENGTH = 8640;
const BRIGHTNESS_DEFAULT = 31;
const BRIGHTNESS_NIGHT = 25;
const ELEVATION_DEFAULT = 4;
const ACTIVE_UNITS_MAX = 40;
const ACTIVE_UNITS_RECT = 960;
const MAX_MONSTER_SPAWNS = 1000;
const MAX_SIGIL_SPAWNS = 10;
const MAX_WORLD_INTERACTIONS = 10;
const SIGIL_DIAMETER = 128;
const CLOSE_LOOT_MENU_DISTANCE = 64;

const MENU_MAIN_SIGIL = 1;
const MENU_MAIN_FIELD_PILLAR = 2;
const MENU_MAIN_CRAFTING = 3;

const PLAYER_DEFAULT_HP = 100;
const PLAYER_DEFAULT_SIGHT = 8;
const PLAYER_DEFAULT_SHIELD = 0;
const PLAYER_DEFAULT_DAMAGE = 6;
const PLAYER_DEFAULT_ATTRIBUTE = 1;
const PLAYER_LIFE_PICKUP_INCREASE = 20 * 256;
const PLAYER_MAX_BELT_SLOTS = 9;

const WEAPON_SHORTSWORD = 1;
const WEAPON_LONGSWORD = 2;
const WEAPON_GREATSWORD = 3;
const WEAPON_SHORTBOW = 4;
const WEAPON_LONGBOW = 5;
const WEAPON_GREATBOW = 6;
const WEAPON_FIREBALL = 7;
const WEAPON_LIGHTNINGBLAST = 8;
const WEAPON_BLADESTORM = 9;
const WEAPON_ANCIENT_TOME_OF_STARFALL = 10;
const WEAPON_CRIMSON_LONG_SWORD = 11;
const WEAPON_CRIMSON_GREAT_BOW = 12;

const UTILITY_DASH = 1;
const UTILITY_TORCH = 2;

const ARMOR_SHATTERED_KNIGHTS = 1;
// const ARMOR_CRIMSON_ENGRAVED_PLATE = 2;

const CONSUMABLE_BANDAGE = 1;
const CONSUMABLE_ELIXER_OF_LIFE = 2;
const CONSUMABLE_FUSE_BOMB = 3;

const MATERIAL_PLANT_FIBER = 1;
const MATERIAL_GARTLE_LEAVES = 2;
const MATERIAL_TARGUS_ROOT = 3;
const MATERIAL_WEEPING_HOOD = 4;
const MATERIAL_IRON_ORE = 5;
const MATERIAL_MITHRIL_ORE = 6;
const MATERIAL_ADAMANTIUM_ORE = 7;
const MATERIAL_GOLD_ORE = 8;
const MATERIAL_SAPPHIRE = 9;
const MATERIAL_EMERALD = 10;
const MATERIAL_RUBY = 11;
const MATERIAL_DIAMOND = 12;
const MATERIAL_LEATHER = 13;
const MATERIAL_BONE = 14;
const MATERIAL_SPIRIT_VENGEANCE = 15;
const MATERIAL_SPIRIT_REMORSE = 16;
const MATERIAL_SPIRIT_TRANQUILITY = 17;
const MATERIAL_SPIRIT_DIVINITY = 18;

const keypress_belt = EUDArray(PLAYER_MAX_BELT_SLOTS * 6);
const keypress_1 = PVariable();
const keypress_2 = PVariable();
const keypress_3 = PVariable();
const keypress_4 = PVariable();
const keypress_5 = PVariable();
const keypress_6 = PVariable();
const keypress_7 = PVariable();
const keypress_8 = PVariable();
const keypress_9 = PVariable();
const keypress_0 = PVariable();
const keypress_f = PVariable();
const keypress_g = PVariable();
EUDRegisterObjectToNamespace("key_1", keypress_1);
EUDRegisterObjectToNamespace("key_2", keypress_2);
EUDRegisterObjectToNamespace("key_3", keypress_3);
EUDRegisterObjectToNamespace("key_4", keypress_4);
EUDRegisterObjectToNamespace("key_5", keypress_5);
EUDRegisterObjectToNamespace("key_6", keypress_6);
EUDRegisterObjectToNamespace("key_7", keypress_7);
EUDRegisterObjectToNamespace("key_8", keypress_8);
EUDRegisterObjectToNamespace("key_9", keypress_9);
EUDRegisterObjectToNamespace("key_0", keypress_0);
EUDRegisterObjectToNamespace("key_f", keypress_f);
EUDRegisterObjectToNamespace("key_g", keypress_g);

/*
    cunit data
    unknown0x26     whether the unit has active physics or not
    unknown0x52
    unknown0x66
    unknown0x86     amount of an item for items
    unknown0x8C
    unknown0x106
    unusedTimer

    0x26 (BYTE)     unknown0x26     supported
    0x52 (WORD)     unknown0x52     supported
    0x66 (WORD)     unknown0x66     supported
    0x86 (BYTE)     unknown0x86     supported
    0x8C (WORD)     unknown0x8C     supported
    0xE8 (DWORD)    --
    0x106 (BYTE)    unknown0x106    supported
    0x125 (BYTE)    unusedTimer     supported
    0x132 (WORD)    unknown0x132    unsupported
 */

// @bm PLAYER VARS
const p_cunit = PVariable(); // holds the cunit pointer of the players unit
const p_x = PVariable(); // coordinates of the unit
const p_y = PVariable();
const p_x_old = PVariable(); 
const p_y_old = PVariable();
const p_angle = PVariable(); // facing angle
const p_orderx = PVariable();
const p_ordery = PVariable();
const p_chunk_x_old = PVariable(); 
const p_chunk_y_old = PVariable();
const p_life = PVariable();
const p_life_max = PVariable();
const p_life_magic_drained = PVariable();
const p_life_regen_consumables = PVariable();
const p_shield = PVariable();
const p_shield_max = PVariable();
const p_shield_recover = PVariable();
const p_shield_broken = PVariable();
const p_damage = PVariable(); // damage of the unit attack
const p_brightness = PVariable();
const p_exp_current = PVariable();
const p_exp_buffer = PVariable();
const p_exp_goal = PVariable();
const p_exp_total = PVariable();
const p_exp_x = PVariable();
const p_exp_y = PVariable();
const p_exp_lost = PVariable();
const p_exp_lost_timer = PVariable();
const p_level_current = PVariable();
const p_armor = PVariable();
const p_homepos_x = PVariable();
const p_homepos_y = PVariable();
const p_indoors = PVariable();
const p_strength = PVariable();
const p_dexterity = PVariable();
const p_resilience = PVariable();
const p_attributepoints = PVariable();
const p_on_sigil = PVariable();
const p_current_sigil = PVariable();
const p_current_item_unit = PVariable();
const p_just_attacked = PVariable();
const p_order_input = PVariable();
const p_death_state = PVariable();
const p_on_world_interaction = PVariable();
const p_interaction_prompt_delay = PVariable();
var p_current_death_hint = 0;
const p_material_fiber_amount = PVariable();
const p_material_gartle_amount = PVariable();
const p_material_targus_amount = PVariable();
const p_material_hood_amount = PVariable();
const p_material_iron_amount = PVariable();
const p_material_mithril_amount = PVariable();
const p_material_adamant_amount = PVariable();
const p_material_gold_amount = PVariable();
const p_material_sapphire_amount = PVariable();
const p_material_emerald_amount = PVariable();
const p_material_ruby_amount = PVariable();
const p_material_diamond_amount = PVariable();
const p_material_leather_amount = PVariable();
const p_material_bone_amount = PVariable();
const p_material_vengeance_amount = PVariable();
const p_material_remorse_amount = PVariable();
const p_material_tranquility_amount = PVariable();
const p_material_divinity_amount = PVariable();
const p_cons_bandage_state = PVariable();
const p_belt_equipped = EUDArray(PLAYER_MAX_BELT_SLOTS * 6);
const p_belt_amount = EUDArray(PLAYER_MAX_BELT_SLOTS * 6);
const p_belt_unlocked = EUDArray(PLAYER_MAX_BELT_SLOTS * 6);
const p_belt_amount_max = PVariable();
const p_entered_lair = PVariable();
const p_nearby_item_unit = PVariable();

const MAX_NPC_UNITS = 30;
const npc_x = EUDArray(MAX_NPC_UNITS);
const npc_y = EUDArray(MAX_NPC_UNITS);
const npc_home_x = EUDArray(MAX_NPC_UNITS);
const npc_home_y = EUDArray(MAX_NPC_UNITS);
const npc_id = EUDArray(MAX_NPC_UNITS);
const npc_cunit = EUDArray(MAX_NPC_UNITS);
const npc_state0 = EUDArray(MAX_NPC_UNITS);
const npc_state1 = EUDArray(MAX_NPC_UNITS);
const npc_state3 = EUDArray(MAX_NPC_UNITS);
const npc_order_timer = EUDArray(MAX_NPC_UNITS);
var npc_cetus_exists = 0;

const MAX_WEAPON_OBJECTS = 6 + 30;
const weapon_cunit = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_id = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_state = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_cooldown = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_angle = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_x = EUDArray(MAX_WEAPON_OBJECTS);
const weapon_y = EUDArray(MAX_WEAPON_OBJECTS);

const MAX_UTILITY_OBJECTS = 6 + 30;
const utility_cunit = EUDArray(MAX_UTILITY_OBJECTS);
const utility_id = EUDArray(MAX_UTILITY_OBJECTS);
const utility_state = EUDArray(MAX_UTILITY_OBJECTS);
const utility_cooldown = EUDArray(MAX_UTILITY_OBJECTS);
const utility_x = EUDArray(MAX_UTILITY_OBJECTS);
const utility_y = EUDArray(MAX_UTILITY_OBJECTS);
const utility_angle = EUDArray(MAX_UTILITY_OBJECTS);

const m_main = PVariable();
const m_page = PVariable();
const m_disable_delay = PVariable(); // this makes it so the menu disables stuff for some time after its closed.

const screen = StringBuffer();
const monster_spawn_type = EUDArray(MAX_MONSTER_SPAWNS);
const monster_spawn_x = EUDArray(MAX_MONSTER_SPAWNS);
const monster_spawn_y = EUDArray(MAX_MONSTER_SPAWNS);
const sigil_x = EUDArray(MAX_SIGIL_SPAWNS);
const sigil_y = EUDArray(MAX_SIGIL_SPAWNS);
const sigil_glow = EUDArray(MAX_SIGIL_SPAWNS);
const world_interaction_x = EUDArray(MAX_WORLD_INTERACTIONS);
const world_interaction_y = EUDArray(MAX_WORLD_INTERACTIONS);
const world_interaction_size = EUDArray(MAX_WORLD_INTERACTIONS);
const chunk_spawns = EUDArray(256);
const chunk_buffer = EUDArray(8);
const active_units = EUDArray(ACTIVE_UNITS_MAX * 6);
var active_units_update = 0;
// @bm DEBUG MODE
const debug_enabled = 1;
const debug_values = EUDArray(8);
var time = 0;
var total_time = 0;
var time_state = 0;
var time_state_changed = 0;
var days_elapsed = 0;
var experience_ping_timer = 0;
var cunit_pathable = 0;
var cunit_checkheight = 0;
var world_interaction_visual_timer = 0;

const field_puzzle_state = EUDArray(3);
const field_puzzle_state_solution = EUDArray(3);

const AUX_ARRAY_SIZE = 20;
const aux_array = EUDArray(20);
function ResetAuxiliaryArray() {
    const actions = py_list();
    foreach(i : py_range(aux_array.length)) {
        actions.append(SetMemoryEPD(EPD(aux_array) + i, SetTo, 0));
    }
    DoActions(actions);  // 1 trigger 20 actions
}

function IsUnitItem(unitType) {
    if (
        unitType == U_WEAPON ||
        unitType == U_ARMOR ||
        unitType == U_LIFEPICKUP ||
        unitType == U_UTILITY ||
        unitType == U_CONSUMABLE
    ) {
        return 1;
    }
    return 0;
}

function isAlly(p: TrgPlayer, tgp: TrgPlayer) {
    if (p == tgp) return 1;
    const q, r = div(tgp, 4);
    const epd = EPD(0x58D634) + q + (3 * p);
    var bitmask;
    switch (r, 3) {
        case 0: bitmask = 3 << 0; break;
        case 1: bitmask = 3 << 8; break;
        case 2: bitmask = 3 << 16; break;
        case 3: bitmask = 3 << 24; break;
    }
    return l2v(MemoryXEPD(epd, AtLeast, 1, bitmask));
}

function PlaySong(id) {
    if (id == 0) PlayWAV("staredit/wav/song0.ogg");
}

function PlaySword() {
    const sound = Random(1, 4);
    if (sound == 1) PlayWAV("staredit/wav/sword1.ogg");
    else if (sound == 2) PlayWAV("staredit/wav/sword2.ogg");
    else if (sound == 3) PlayWAV("staredit/wav/sword3.ogg");
    else if (sound == 4) PlayWAV("staredit/wav/sword4.ogg");
}

function PlayArrow() {
    const sound = Random(1, 4);
    if (sound == 1) PlayWAV("staredit/wav/arrow1.ogg");
    else if (sound == 2) PlayWAV("staredit/wav/arrow2.ogg");
    else if (sound == 3) PlayWAV("staredit/wav/arrow3.ogg");
    else if (sound == 4) PlayWAV("staredit/wav/arrow4.ogg");
}

function GetRandomSoundArrow() : TrgString {
    const sound = Random(1, 4);
    if (sound == 1) return $T("staredit/wav/arrow1.ogg");
    else if (sound == 2) return $T("staredit/wav/arrow2.ogg");
    else if (sound == 3) return $T("staredit/wav/arrow3.ogg");
    else if (sound == 4) return $T("staredit/wav/arrow4.ogg");
}

function GetStringItemName(item_id, unitID) {
    if (unitID == U_WEAPON) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case WEAPON_SHORTSWORD: return Db("Short Sword");
            case WEAPON_SHORTBOW: return Db("Short Bow");
            case WEAPON_FIREBALL: return Db("Tome Of Fireball");
            case WEAPON_ANCIENT_TOME_OF_STARFALL: return Db("Ancient Tome Of Starfall");
            case WEAPON_LONGSWORD: return Db("Long Sword");
            case WEAPON_GREATSWORD: return Db("Great Sword");
            case WEAPON_LONGBOW: return Db("Long Bow");
            case WEAPON_GREATBOW: return Db("Great Bow");
            case WEAPON_LIGHTNINGBLAST: return Db("Tome Of Lightning Blast");
            case WEAPON_BLADESTORM: return Db("Tome Of Blade Storm");
            case WEAPON_CRIMSON_LONG_SWORD: return Db("Crimson Long Sword");
            case WEAPON_CRIMSON_GREAT_BOW: return Db("Crimson Great Bow");
	    }
    } else if (unitID == U_ARMOR) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case ARMOR_SHATTERED_KNIGHTS: return Db("Shattered Knight's Armor");
        }
    } else if (unitID == U_UTILITY) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case UTILITY_DASH: return Db("Tome Of Dash");
            case UTILITY_TORCH: return Db("Torch");
        }
    } else if (unitID == U_CONSUMABLE) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case CONSUMABLE_BANDAGE: return Db("Bandage");
            case CONSUMABLE_ELIXER_OF_LIFE: return Db("Elixer Of Life");
            case CONSUMABLE_FUSE_BOMB: return Db("Fuse Bomb");
        }
    }
}

function GetStringItemDescription(item_id, unitID) {
    if (unitID == U_WEAPON) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case WEAPON_SHORTSWORD: return Db("A basic sword meant for utility and consistency.");
            case WEAPON_SHORTBOW: return Db("A basic ranger's bow, appreciated for its swiftness.");
            case WEAPON_FIREBALL: return Db("An old, common, and lethal, magical writing.");
            case WEAPON_ANCIENT_TOME_OF_STARFALL: return Db("An ancient secret weapon passed down to only the most legendary ranks.");
            case WEAPON_LONGSWORD: return Db("An agile and weighty sword.");
            case WEAPON_GREATSWORD: return Db("A slow and powerful sword.");
            case WEAPON_LONGBOW: return Db("A bow with medium range and effectiveness.");
            case WEAPON_GREATBOW: return Db("A massive bow with immense velocity.");
            case WEAPON_LIGHTNINGBLAST: return Db("Call upon sparks of energy to destroy foes.");
            case WEAPON_BLADESTORM: return Db("A deadly art intended for close combat.");
            case WEAPON_CRIMSON_LONG_SWORD: return Db("Corrupted and demonic ancient blade.");
            case WEAPON_CRIMSON_GREAT_BOW: return Db("Corrupted and demonic ancient bow.");
	    }
    } else if (unitID == U_ARMOR) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case ARMOR_SHATTERED_KNIGHTS: return Db("Some damaged old armor from another life.");
        }
    } else if (unitID == U_UTILITY) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case UTILITY_DASH: return Db("Powerful charge that throws the user forward.");
            case UTILITY_TORCH: return Db("Useful flaming torch for lighting up dark places.");
        }
    } else if (unitID == U_CONSUMABLE) {
        switch(item_id) {
            case 0: return Db("Nothing");
            case CONSUMABLE_BANDAGE: return Db("Heals 25 Life over some period of time.");
            case CONSUMABLE_ELIXER_OF_LIFE: return Db("Heals 25 Life instantly.");
            case CONSUMABLE_FUSE_BOMB: return Db("Violently explodes after some period of time.");
        }
    }
}

function GetStringMaterialName(materialID) {
    switch(materialID) {
        case 0: return Db("Nothing");
        case MATERIAL_PLANT_FIBER: return Db("\x1DPlant Fiber");
        case MATERIAL_GARTLE_LEAVES: return Db("\x18Gartle Leaves");
        case MATERIAL_TARGUS_ROOT: return Db("\x19Targus Root");
        case MATERIAL_WEEPING_HOOD: return Db("\x10Weeping Hood");
        case MATERIAL_IRON_ORE: return Db("\x10Iron Ore");
        case MATERIAL_MITHRIL_ORE: return Db("\x10Mithril Ore");
        case MATERIAL_ADAMANTIUM_ORE: return Db("\x10Adamantium Ore");
        case MATERIAL_GOLD_ORE: return Db("\x10Gold Ore");
        case MATERIAL_SAPPHIRE: return Db("\x10Sapphire");
        case MATERIAL_EMERALD: return Db("\x10Emerald");
        case MATERIAL_RUBY: return Db("\x10Ruby");
        case MATERIAL_DIAMOND: return Db("\x10Diamond");
        case MATERIAL_LEATHER: return Db("\x10Leather");
        case MATERIAL_BONE: return Db("\x10Bone");
        case MATERIAL_SPIRIT_VENGEANCE: return Db("\x10Spirit Of Vengeance");
        case MATERIAL_SPIRIT_REMORSE: return Db("\x10Spirit Of Remorse");
        case MATERIAL_SPIRIT_TRANQUILITY: return Db("\x10Spirit Of Tranquility");
        case MATERIAL_SPIRIT_DIVINITY: return Db("\x10Spirit Of Divinity");
    }
}

function GetStringIngredients(itemID, itemUnitID) {
    if (itemUnitID == U_CONSUMABLE) {
        switch(itemID) {
            case 0: return Db("Nothing");
            case CONSUMABLE_BANDAGE: return Db("(Plant Fiber x2)");
            case CONSUMABLE_ELIXER_OF_LIFE: return Db("(Gartle Leaves x2)");
            case CONSUMABLE_FUSE_BOMB: return Db("(Plant Fiber x2, Iron Ore x1, Targus Root x1)");
        }
    }
}

function GetStringHint(id) {
    switch(id) {
        case 0: return Db("Don't forget to dodge in combat. Dodging is when you recover your armor by backing away from foes.");
        case 1: return Db("Only aggravate as many enemies as you can handle.");
        case 2: return Db("The penalty for death is dropping your current experience. Which you can recover if you reach it in time.");
        case 3: return Db("hint");
        case 4: return Db("hint");
        case 5: return Db("hint");
        case 6: return Db("hint");
        case 7: return Db("hint");
        case 8: return Db("hint");
        case 9: return Db("hint");
        case 10: return Db("hint");
	}
}

function GetStringWorldInteractionPrompt(id) {
    switch(id) {
        case 0, 1, 2: return Db("\x13\x04Press \x03-<F>- \x04to Examine the Pillar.");
        case 3: return Db("\x13\x04Press \x03-<F>- \x04to Read a note left in the grass.");
        case 4: return Db("\x13\x04Press \x03-<F>- \x04to Use the Crafting Table.");
        case 5: return Db("hint");
        case 6: return Db("hint");
        case 7: return Db("hint");
        case 8: return Db("hint");
        case 9: return Db("hint");
        case 10: return Db("hint");
	}
}

function MenuIsOpen(playerID) {
    if (
        m_main[playerID] > 0 ||
        p_current_item_unit[playerID] > 0 ||
        m_disable_delay[playerID] > 0
    ) {
        return 1;
    }
    return 0;
}

function BeltIsFull(playerID) {
    const check_from = playerID * PLAYER_MAX_BELT_SLOTS;
    const check_to = check_from + PLAYER_MAX_BELT_SLOTS;
    for (var i = check_from; i < check_to; i++) {
        if (p_belt_amount[i] < p_belt_amount_max[playerID] && p_belt_unlocked[i]) return 0;
        else if (!p_belt_unlocked[i]) return 1;
    }
    return 1;
}

function GetBeltSlotItemID(playerID, slotID) {
    const index = (playerID * PLAYER_MAX_BELT_SLOTS) + slotID;
    return p_belt_equipped[index];
}

function GetBeltSlotAmount(playerID, slotID) { // slotID should be 0 - 8
    const index = (playerID * PLAYER_MAX_BELT_SLOTS) + slotID;
    return p_belt_amount[index];
}

function GetInputBeltKeypress(playerID) {
    const check_from = playerID * PLAYER_MAX_BELT_SLOTS;
    const check_to = check_from + PLAYER_MAX_BELT_SLOTS;
    for (var i = check_from; i < check_to; i++) {
        if (keypress_belt[i] > 0) return i + 1;
    }
    return 0;
}

function GetItemInteractionIDs(itemID, itemUnitID) {
    /*
    0 = none
    1 = equip
    2 = equip to available belt slot
    3 = equip to specific belt slot
    4 = drag
     */
    var id0, id1, id2 = 0, 0, 0;
    if (
        itemUnitID == U_WEAPON ||
        itemUnitID == U_ARMOR ||
        itemUnitID == U_UTILITY
    ) {
        id0, id1, id2 = 1, 4, 0;
    } 
    else if (itemUnitID == U_CONSUMABLE) {
        id0, id1, id2 = 2, 3, 4;
    }
    return id0, id1, id2;
}

function SetupBeltDefaults() {
    for (var i = 0; i < MAX_PLAYERS; i++) {
        p_belt_amount_max[i] = 3;
    }
}

function SetupSystemUnits() {
    cunit_checkheight = CUnit.from_read(EPD(0x628438));
    CreateUnitWithProperties(1, U_CHECKHEIGHT, L_CHECK, $P8, UnitProperty(invincible = true));
    GiveUnits(1, U_CHECKHEIGHT, $P8, L_ANYWHERE, $P12);
    cunit_pathable = CUnit.from_read(EPD(0x628438));
    CreateUnitWithProperties(1, U_PATHABLE, L_CHECK, $P8, UnitProperty(invincible = true));
    GiveUnits(1, U_PATHABLE, $P8, L_ANYWHERE, $P12);
    const cunit_checkterrain = CUnit.from_read(EPD(0x628438));
    CreateUnitWithProperties(1, U_CHECK_TERRAIN_COLLIDER, L_CHECK, $P8, UnitProperty(invincible = true));
    GiveUnits(1, U_CHECK_TERRAIN_COLLIDER, $P8, L_ANYWHERE, $P12);
    cunit_checkterrain.orderID = 116;
}

function SetupWorldInteractions() {
    world_interaction_x[0], world_interaction_y[0] = 3160, 1840; world_interaction_size[0] = 128; // field puzzle
    world_interaction_x[1], world_interaction_y[1] = 3176, 2800; world_interaction_size[1] = 128;
    world_interaction_x[2], world_interaction_y[2] = 1976, 2672; world_interaction_size[2] = 128;
    world_interaction_x[3], world_interaction_y[3] = 2656, 2350; world_interaction_size[3] = 64; // juyet's note at the field sigil
    world_interaction_x[4], world_interaction_y[4] = 3360, 1024; world_interaction_size[4] = 128; // crafting table in grassy cave.
    // randomize solutions
    var solution1_used = 0;
    var solution2_used = 0;
    var solution3_used = 0;
    var solution4_used = 0;
    for (var i = 0; i < 3; i++) {
        var r = Random(1, 4);
        while (field_puzzle_state_solution[i] == 0) {
            if (!solution1_used && r == 1) {
                solution1_used = 1;
                field_puzzle_state_solution[i] = 1;
                break;
            } else if (!solution2_used && r == 2) {
                solution2_used = 1;
                field_puzzle_state_solution[i] = 2;
                break;
            } else if (!solution3_used && r == 3) {
                solution3_used = 1;
                field_puzzle_state_solution[i] = 3;
                break;
            } else if (!solution4_used && r == 4) {
                solution4_used = 1;
                field_puzzle_state_solution[i] = 4;
                break;
            } else if (r >= 4) r = 0;
            else r++;
        }
    }
    // randomize positions
    for (var i = 0; i < 3; i++) field_puzzle_state[i] = Random(1, 4);
    if (field_puzzle_state[0] == field_puzzle_state_solution[0] && field_puzzle_state[1] == field_puzzle_state_solution[1] && field_puzzle_state[2] == field_puzzle_state_solution[2]) {
        const r_index = Random(0, 2);
        if (field_puzzle_state[r_index] >= 4) field_puzzle_state[r_index] = 0;
        else field_puzzle_state[r_index]++;
    }
}

function ResetWorldInteractionIndex(index) {
    world_interaction_x[index] = 0;
    world_interaction_y[index] = 0;
    world_interaction_size[index] = 0;
}

function GetWholeAndFraction(value) {
    // takes in a value * 10000 and returns the whole numbers + the fraction separately.
    var new_value = value;
    const whole = value / 10000;
    new_value -= (10000 * whole);
    const fraction = new_value;
    return whole, fraction;
}

function GetPercentage(currentValue, maxValue) {
    const new_current = currentValue * 10000;
    const percentage = (new_current / maxValue) * 100;
    return percentage / 10000;
}

function GetHealthToughnessDeduction(playerID, damage_amount) {
    // every point of dexterity = 2% damage reduced to the damage_amount.
    const percent_deducted = (p_dexterity[playerID] * 2) * 100;
    const deduction = (damage_amount * percent_deducted) / 10000;
    return deduction;
}

function GetArmorToughnessDeduction(playerID, damage_amount) {
    // every point of resilience = 2% damage reduced to the damage_amount.
    const percent_deducted = (p_resilience[playerID] * 2) * 100;
    const deduction = (damage_amount * percent_deducted) / 10000;
    return deduction;
}

function GetAttackSpeed(playerID) {
    var value = p_dexterity[playerID];
    if (value > 20) value = 20;
    return value;
}

function CalculateKnightSwordDamage(playerID) {
    p_damage[playerID] = PLAYER_DEFAULT_DAMAGE + (p_strength[playerID] * 2);
}

function GetHealthRegen(playerID) { // 2 per frame = 0.1875 per second
    var regen = 2 * p_strength[playerID]; // strength regen
    var magic_drain_rate = 4 * p_resilience[playerID]; // magic drain regen
    if (p_life_magic_drained[playerID] >= magic_drain_rate) {
        regen += magic_drain_rate;
        p_life_magic_drained[playerID] -= magic_drain_rate;
    } else if (p_life_magic_drained[playerID] > 0) {
        regen += p_life_magic_drained[playerID];
        p_life_magic_drained[playerID] = 0;
    }
    const consumable_rate = 128;
    if (p_life_regen_consumables[playerID] >= consumable_rate) {
        regen += consumable_rate;
        p_life_regen_consumables[playerID] -= consumable_rate;
    } else if (p_life_regen_consumables[playerID] > 0) {
        regen += p_life_regen_consumables[playerID];
        p_life_regen_consumables[playerID] = 0;
    }
    return regen;
}
// @bm GetWeaponCooldown
function GetWeaponCooldown(item_id, playerID) {
    if (item_id == WEAPON_SHORTSWORD) return 96;
    else if (item_id == WEAPON_LONGSWORD) return 156;
    else if (item_id == WEAPON_GREATSWORD) return 204;
    else if (item_id == WEAPON_SHORTBOW) return 36;
    else if (item_id == WEAPON_LONGBOW) return 48;
    else if (item_id == WEAPON_GREATBOW) return 96;
    else if (item_id == WEAPON_FIREBALL) return 48;
    else if (item_id == WEAPON_LIGHTNINGBLAST) return 120;
    else if (item_id == WEAPON_BLADESTORM) return 48;
    else if (item_id == WEAPON_ANCIENT_TOME_OF_STARFALL) return 24;
    else if (item_id == WEAPON_CRIMSON_LONG_SWORD) return 156;
    else if (item_id == WEAPON_CRIMSON_GREAT_BOW) return 48; // 120
}

function GetWeaponDamage(itemID, state, playerID) { // in the future could make unit an argument so that can have different damage based on unitid
    var damage = 0;
    if (playerID >= 0 && playerID <= 5) {
        if (itemID == WEAPON_SHORTSWORD) damage = 6 + (1 * p_strength[playerID]);
        else if (itemID == WEAPON_SHORTBOW) damage = 10 + (2 * p_dexterity[playerID]);
        else if (itemID == WEAPON_FIREBALL) damage = 4 + (2 * p_resilience[playerID]);
        else if (itemID == WEAPON_ANCIENT_TOME_OF_STARFALL) damage = 50 + (5 * p_resilience[playerID]);
        else if (itemID == WEAPON_LONGSWORD) damage = 9 + (1 * p_strength[playerID]);
        else if (itemID == WEAPON_GREATSWORD) damage = 10 + (2 * p_strength[playerID]);
        else if (itemID == WEAPON_LONGBOW) damage = 10 + (2 * p_dexterity[playerID]);
        else if (itemID == WEAPON_GREATBOW) damage = 10 + (2 * p_dexterity[playerID]);
        else if (itemID == WEAPON_LIGHTNINGBLAST && state == 0) damage = 8 + (2 * p_resilience[playerID]);
        else if (itemID == WEAPON_LIGHTNINGBLAST && state == 1) damage = 4 + (2 * p_resilience[playerID]);
        else if (itemID == WEAPON_BLADESTORM) damage = 4 + (2 * p_resilience[playerID]);
        else if (itemID == WEAPON_CRIMSON_LONG_SWORD) damage = 30 + p_strength[playerID];
    } else if (playerID == $P7) {
        if (itemID == WEAPON_SHORTSWORD) damage = 30;
        else if (itemID == WEAPON_SHORTBOW) damage = 50;
        else if (itemID == WEAPON_FIREBALL) damage = 50;
        else if (itemID == WEAPON_ANCIENT_TOME_OF_STARFALL) damage = 1000;
        else if (itemID == WEAPON_LONGSWORD) damage = 50;
        else if (itemID == WEAPON_GREATSWORD) damage = 35;
        else if (itemID == WEAPON_LONGBOW) damage = 50;
        else if (itemID == WEAPON_GREATBOW) damage = 50;
        else if (itemID == WEAPON_LIGHTNINGBLAST) damage = 50;
        else if (itemID == WEAPON_BLADESTORM) damage = 50;
        else if (itemID == WEAPON_CRIMSON_LONG_SWORD) damage = 50;
    }
    return damage;
}

function GetWeaponLifeCost(item_id, playerID) {
    var life_cost = 0;
    if (playerID > 5) return 0;
    if (item_id == WEAPON_FIREBALL) life_cost = 10 * 256;
    else if (item_id == WEAPON_LIGHTNINGBLAST) life_cost = 25 * 256;
    else if (item_id == WEAPON_ANCIENT_TOME_OF_STARFALL) life_cost = 99 * 256;
    return life_cost;
}
// @bm CheckForWeaponTrigger
function CheckForWeaponTrigger(playerID, unit: CUnit, item_id) {
    var is_player = 0;
    var weapon_was_triggered = 0;
    var player_attack_clicked = 0;
    if (playerID < 6) is_player = 1;
    if ((is_player && unit.orderID == 14) || (is_player && unit.orderID == 10)) player_attack_clicked = 1;
    if (item_id == WEAPON_SHORTSWORD) {
        if (is_player && p_just_attacked[playerID] > 0) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.groundWeaponCooldown == 7) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_SHORTBOW) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.groundWeaponCooldown == 7) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_HILL_SPINT && unit.orderID != 3) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_TWISTED_KNIGHT && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_FIREBALL) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.groundWeaponCooldown == 7) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_TWISTED_KNIGHT && unit.groundWeaponCooldown == 2) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_ANCIENT_TOME_OF_STARFALL) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_GUARDIAN_ANGEL && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_LONGSWORD) {
        if (is_player && p_just_attacked[playerID] > 0) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_GREATSWORD) {
        if (is_player && p_just_attacked[playerID] > 0) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_TWISTED_KNIGHT && unit.groundWeaponCooldown == 2) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_LONGBOW) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_GREATBOW) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_LIGHTNINGBLAST) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_TWISTED_KNIGHT && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_BLADESTORM) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_CHIMERA && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_CRIMSON_LONG_SWORD) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_LOST_KNIGHT && unit.orderID != 3) weapon_was_triggered = 1;
    }
    else if (item_id == WEAPON_CRIMSON_GREAT_BOW) {
        if (player_attack_clicked) weapon_was_triggered = 1;
        else if (playerID == $P7 && unit.unitID == U_LOST_KNIGHT && unit.orderID != 3) weapon_was_triggered = 1;
    }
    const target = unit.orderTargetUnit;
    if (weapon_was_triggered && IsUnitItem(target.unitID)) weapon_was_triggered = 0;
    return weapon_was_triggered;
}

function GetUtilityCooldown(itemID) {
    if (itemID == UTILITY_DASH) return 24; // 144
    else if (itemID == UTILITY_TORCH) return 0;
}

function GetUtilityLifeCost(itemID, playerID) {
    var life_cost = 0;
    if (playerID > 5) return 0;
    if (itemID == UTILITY_DASH) life_cost = 10 * 256;
    return life_cost;
}

function CheckForUtilityTrigger(playerID, unit: CUnit, itemID) {
    var is_player = 0;
    var utility_was_triggered = 0;
    if (playerID < 6) is_player = 1;
    if (itemID == UTILITY_DASH) {
        if (is_player && p_order_input[playerID] == ORDER_PATROL) utility_was_triggered = 1;
    }
    return utility_was_triggered;
}

function AttachWeaponToUnit(unit_ptr, itemID) {
    for (var i = 6; i < MAX_WEAPON_OBJECTS; i++) {
        if (weapon_id[i] == 0) {
            weapon_id[i] = itemID;
            weapon_cunit[i] = unit_ptr;
            break;
        }
    }
}

function GetDistance(originx, originy, destx, desty) {
    const a = originx - destx;
    const b = originy - desty;
    const distance = sqrt( a*a + b*b );
    return distance;
}

function MovePosTowards(positionx, positiony, angle, distance) {
    const directionx, directiony = lengthdir(distance, angle);
    const new_positionx = positionx + directionx;
    const new_positiony = positiony + directiony;
    return new_positionx, new_positiony;
}

function GetLocationPoint(location) {
	const locTable = EPD(0x58DC4C);
	return dwread_epd(locTable + location * 5), dwread_epd(locTable + location * 5 + 1);
}

function CenterLoc(location, x, y) {
    setloc(L_MAIN, x, y);
    MoveLocation(location, $U("Map Revealer"), $P12, L_MAIN);
}

function CenterLocHero(location, playerID) {
    MoveLocation(location, U_HERO[playerID], playerID, L_ANYWHERE);
}

function HeroIsAt(location, playerID) {
    if (Bring(playerID, AtLeast, 1, U_HERO[playerID], location)) return 1;
    return 0;
}

function EnemiesAtLoc(location) {
    if (Bring(Foes, AtLeast, 1, U_ANY, location)) return 1;
    return 0;
}

function PosIsWithinRect(positionx, positiony, left, right, top, bottom) {
    if (positionx >= left && positionx <= right && positiony >= top && positiony <= bottom) return 1;
    return 0;
}

const AREA_GATE_MOUNTAIN = 1;
const AREA_FIELD = 2;
const AREA_CETUS_LAIR = 3;
function GetAreaAtPos(positionx, positiony) {
    if (PosIsWithinRect(positionx, positiony, 540, 2970, 0, 896)) return AREA_GATE_MOUNTAIN;
    if (PosIsWithinRect(positionx, positiony, 1664, 1920, 897, 1024)) return AREA_GATE_MOUNTAIN;
    if (PosIsWithinRect(positionx, positiony, 1620, 3740, 1632, 3040)) return AREA_FIELD;
    if (PosIsWithinRect(positionx, positiony, 64, 770, 1250, 1860)) return AREA_CETUS_LAIR;
    return 0;
}

const players_at_area = EUDArray(6);
function PlayersAtArea(areaID) {
    var condition_met = 0;
    foreach(player : EUDLoopPlayer()) {
        if (GetAreaAtPos(p_x[player], p_y[player]) == areaID) {
            condition_met = 1;
            players_at_area[player] = 1;
        } else {
            players_at_area[player] = 0;
        }
    }
    return condition_met;
}

function StandingOnSigil(positionx, positiony) {
    for (var i = 0; i < MAX_SIGIL_SPAWNS; i++) {
        if (sigil_x[i] > 0) {
            const dist = GetDistance(positionx, positiony, sigil_x[i], sigil_y[i]);
            if (dist <= 64) return i;
        }
    }
    return MAX_SIGIL_SPAWNS + 1;
}

function GetSumOfActivePlayerBits() {
    var sum = 0;
    if (playerexist($P1)) sum += 1;
    if (playerexist($P2)) sum += 2;
    if (playerexist($P3)) sum += 4;
    if (playerexist($P4)) sum += 8;
    if (playerexist($P5)) sum += 16;
    if (playerexist($P6)) sum += 32;
    return sum;
}

function CreateCUnit(unitType, playerID, location) : CUnit {
	const newUnit = CUnit.from_read(EPD(0x628438));
	CreateUnit(1, unitType, L_UNITBUFFER, playerID);
    MoveUnit(1, unitType, playerID, L_UNITBUFFER, location);
    if (Bring(playerID, AtLeast, 1, unitType, L_UNITBUFFER)) {
        RemoveUnitAt(All, unitType, L_UNITBUFFER, playerID);
        return 0;
    }
	return newUnit;
}

function CreateItemUnit(unitType, item_id, location, acquisition_state, amount) {
    const new_unit = CUnit(CreateCUnit(unitType, $P8, location));
    if (item_id > 0) new_unit.energy = item_id;
    if (acquisition_state > 0) new_unit.shield = GetSumOfActivePlayerBits();
    else new_unit.shield = 1000;
    new_unit.unknown0x86 = amount;
}

function CreateUnitCircle(unitType, playerID, location, diameter, amount) {
    const locx, locy = GetLocationPoint(location);
    var angle_increment = (3600000 / amount) / 10000;
    var angle = 0;
    for (var i = 0; i < amount; i++) {
        const x, y = MovePosTowards(locx, locy, angle, diameter / 2);
        setloc(L_MAIN, x, y);
        CreateUnit(1, unitType, L_UNITBUFFER, playerID);
        MoveUnit(1, unitType, playerID, L_UNITBUFFER, L_MAIN);
        if (Bring(playerID, AtLeast, 1, unitType, L_UNITBUFFER)) RemoveUnitAt(All, unitType, L_UNITBUFFER, playerID);
        angle += angle_increment;
    }
}

function MakeUnitNPC(unit: CUnit, npcID) {
    for (var i = 0; i < MAX_NPC_UNITS; i++) {
        if (npc_id[i] == 0) {
            npc_cunit[i] = unit;
            npc_id[i] = npcID;
            npc_home_x[i] = unit.posX;
            npc_home_y[i] = unit.posY;
            break;
        }
        if (i == MAX_NPC_UNITS - 1) {
            DisplayTextAll("ALERT: MAX NPCS REACHED");
        }
    }
}

function GetVision(playerID) {
    if (playerID == 0) RunAIScript("+Vi0");
    else if (playerID == 1) RunAIScript("+Vi1");
    else if (playerID == 2) RunAIScript("+Vi2");
    else if (playerID == 3) RunAIScript("+Vi3");
    else if (playerID == 4) RunAIScript("+Vi4");
    else if (playerID == 5) RunAIScript("+Vi5");
    else if (playerID == 6) RunAIScript("+Vi6");
    else if (playerID == 7) RunAIScript("+Vi7");
}

function LoseVision(playerID) {
    if (playerID == 0) RunAIScript("-Vi0");
    else if (playerID == 1) RunAIScript("-Vi1");
    else if (playerID == 2) RunAIScript("-Vi2");
    else if (playerID == 3) RunAIScript("-Vi3");
    else if (playerID == 4) RunAIScript("-Vi4");
    else if (playerID == 5) RunAIScript("-Vi5");
    else if (playerID == 6) RunAIScript("-Vi6");
    else if (playerID == 7) RunAIScript("-Vi7");
}

function CreateUnitDeathAtLocation(unitType, playerID, location) {
    CreateUnit(1, unitType, L_UNITBUFFER, playerID);
    MoveUnit(1, unitType, playerID, L_UNITBUFFER, location);
    if (Bring(playerID, AtLeast, 1, unitType, L_UNITBUFFER)) RemoveUnitAt(All, unitType, L_UNITBUFFER, playerID);
    KillUnit(unitType, playerID);
}

function StoreSpawnPositions() {
    var monster_i = 0;
    var sigil_i = 0;
    foreach(unit : EUDLoopCUnit()) {
        if (unit.playerID == $P9) {
            if (unit.unitType == 215 && sigil_i < MAX_SIGIL_SPAWNS) {
                sigil_i++;
                sigil_x[sigil_i] = unit.posX;
                sigil_y[sigil_i] = unit.posY;
                unit.remove();
            } 
            else if (monster_i < MAX_MONSTER_SPAWNS) {
                monster_spawn_type[monster_i] = unit.unitType;
                monster_spawn_x[monster_i] = unit.posX;
                monster_spawn_y[monster_i] = unit.posY;
                unit.remove();
                monster_i++;
                if (monster_i > MAX_MONSTER_SPAWNS) {
                    DisplayTextAll("NOTICE: MAXIMUM SPAWN POSITIONS REACHED!");
                    break;
                }
            }

        }
    }
}

const MAX_HARVEST_POSITIONS = 100;
const harvest_x = EUDArray(MAX_HARVEST_POSITIONS);
const harvest_y = EUDArray(MAX_HARVEST_POSITIONS);
const harvest_type = EUDArray(MAX_HARVEST_POSITIONS);
const harvest_state = EUDArray(MAX_HARVEST_POSITIONS);
function StoreHarvestPositions() {
    var harvest_i = 0;
    foreach(unit : EUDLoopCUnit()) {
        if (unit.unitType == U_HARVEST_MARKER) {
            if (unit.playerID == $P9) harvest_type[harvest_i] = MATERIAL_GARTLE_LEAVES;
            else if (unit.playerID == $P10) harvest_type[harvest_i] = MATERIAL_WEEPING_HOOD;
            else if (unit.playerID == $P11) harvest_type[harvest_i] = MATERIAL_TARGUS_ROOT;
            harvest_x[harvest_i], harvest_y[harvest_i] = unit.posX, unit.posY;
            harvest_state[harvest_i] = GetSumOfActivePlayerBits();
            unit.remove();
            harvest_i++;
            if (harvest_i >= MAX_HARVEST_POSITIONS) {
                DisplayTextAll("NOTICE: MAX HARVEST POSITIONS REACHED!");
                break;
            }
        }
    }
}

function SpawnInitialItemUnits() {
    foreach(unit : EUDLoopCUnit()) {  // TODO: refactor the if statements in the future to not be retarded?
        if (unit.playerID == $P8) {
            if (unit.unitType == U_MARKER) {
                const consumable_item_id = unit.hp / 256;
                setloc(L_MAIN, unit.posX, unit.posY);
                RemoveUnitAt(1, U_MARKER, L_MAIN, $P8);
                const new_unit = CUnit(CreateCUnit(U_CONSUMABLE, $P8, L_MAIN));
                new_unit.energy = consumable_item_id;
                new_unit.shield = GetSumOfActivePlayerBits();
                new_unit.unknown0x86 = 5;
            }
        } else if (unit.playerID == $P9) {
            if (unit.unitType == U_MARKER) {
                const utility_item_id = unit.hp / 256;
                setloc(L_MAIN, unit.posX, unit.posY);
                RemoveUnitAt(1, U_MARKER, L_MAIN, $P9);
                const new_unit = CUnit(CreateCUnit(U_UTILITY, $P8, L_MAIN));
                new_unit.energy = utility_item_id;
                new_unit.shield = GetSumOfActivePlayerBits();
            }
        } else if (unit.playerID == $P10) {
            if (unit.unitType == U_MARKER) {
                const weapon_item_id = unit.hp / 256;
                setloc(L_MAIN, unit.posX, unit.posY);
                RemoveUnitAt(1, U_MARKER, L_MAIN, $P10);
                const new_unit = CUnit(CreateCUnit(U_WEAPON, $P8, L_MAIN));
                new_unit.energy = weapon_item_id;
                new_unit.shield = GetSumOfActivePlayerBits();
            }
        } else if (unit.playerID == $P11) {
            if (unit.unitType == U_MARKER) {
                const armor_id = unit.hp / 256;
                setloc(L_MAIN, unit.posX, unit.posY);
                RemoveUnitAt(1, U_MARKER, L_MAIN, $P11);
                const new_unit = CUnit(CreateCUnit(U_ARMOR, $P8, L_MAIN));
                new_unit.energy = armor_id;
                new_unit.shield = GetSumOfActivePlayerBits();
            }
        } else if (unit.playerID == $P12) {
            if (unit.unitType == U_MARKER) {
                const special_id = unit.hp / 256;
                var create_unit = 0;
                setloc(L_MAIN, unit.posX, unit.posY);
                RemoveUnitAt(1, U_MARKER, L_MAIN, $P12);
                if (special_id == 1) create_unit = U_LIFEPICKUP;
                const new_unit = CUnit(CreateCUnit(create_unit, $P8, L_MAIN));
                new_unit.shield = GetSumOfActivePlayerBits();
            }
        }
    }
}

function UnitItemHasBeenLooted(playerID, value) {
    if (value > 63) return 0;
    var check_bits = value;
    var p0, p1, p2, p3, p4, p5 = 0, 0, 0, 0, 0, 0;
    if (check_bits >= 32) {check_bits -= 32; p5 = 1;}
    if (check_bits >= 16) {check_bits -= 16; p4 = 1;}
    if (check_bits >= 8) {check_bits -= 8; p3 = 1;}
    if (check_bits >= 4) {check_bits -= 4; p2 = 1;}
    if (check_bits >= 2) {check_bits -= 2; p1 = 1;}
    if (check_bits >= 1) {check_bits -= 1; p0 = 1;}
    if (playerID == 0 && p0 > 0) return 0;
    else if (playerID == 1 && p1 > 0) return 0;
    else if (playerID == 2 && p2 > 0) return 0;
    else if (playerID == 3 && p3 > 0) return 0;
    else if (playerID == 4 && p4 > 0) return 0;
    else if (playerID == 5 && p5 > 0) return 0;
    return 1;
}

function ModifyItemLootedStatus(playerID, current_value) {
    if (current_value >= 1000) return 0; // return 0 if the item is non-shared
    var new_value = current_value;
    if (playerID == 0) new_value -= 1;
    else if (playerID == 1) new_value -= 2;
    else if (playerID == 2) new_value -= 4;
    else if (playerID == 3) new_value -= 8;
    else if (playerID == 4) new_value -= 16;
    else if (playerID == 5) new_value -= 32;
    return new_value; // if this returns 0 the item should be removed from the map
}

function IsAlive(playerID) {
    if (Command(playerID, AtLeast, 1, U_HERO[playerID])) return 1;
    return 0;
}

function TeleportHeroPos(playerID, positionx, positiony) {
    setloc(L_MAIN, positionx, positiony);
    MoveUnit(1, U_HERO[playerID], playerID, L_ANYWHERE, L_MAIN);
    const unit = CUnit(p_cunit[playerID]);
    p_x[playerID], p_y[playerID] = unit.posX, unit.posY;
}

function PlayWavAtPos(sound_path_string: TrgString, positionx, positiony, max_distance) {
    for (var i = 0; i < 6; i++) {
        if (IsAlive(i) && GetDistance(p_x[i], p_y[i], positionx, positiony) <= max_distance) {
            const old_cp = getcurpl();
            setcurpl(i);
            PlayWAV(sound_path_string);
            setcurpl(old_cp);
        }
    }
}

function PlayWAVCP(sound_path_string: TrgString, playerID) {
    if (playerID > 7) return;
    const old_cp = getcurpl();
    setcurpl(playerID);
    PlayWAV(sound_path_string);
    setcurpl(old_cp);
}

function IsPosIndoors(positionx, positiony) {
    if (PosIsWithinRect(positionx, positiony, 3840, 4390, 1630, 2340)) return 1;
    if (PosIsWithinRect(positionx, positiony, 2870, 3580, 890, 1440)) return 1;
    if (PosIsWithinRect(positionx, positiony, 0, 1280, 1280, 2660)) return 1;
    if (PosIsWithinRect(positionx, positiony, 1281, 1890, 1470, 2150)) return 1;
    if (PosIsWithinRect(positionx, positiony, 1281, 1632, 2151, 2480)) return 1;
    if (PosIsWithinRect(positionx, positiony, 1632, 1696, 2270, 2370)) return 1;
    if (PosIsWithinRect(positionx, positiony, 3105, 3290, 3160, 3488)) return 1;
    return 0;
}

function CreateImageSpriteAtLocation(playerID, location, imageID, drawFunc, iscript) {
    var new_iscript = iscript;
    if (new_iscript == 0) new_iscript = ISCRIPT_NORMAL;
    const prev_iscript = dwread(0x666778 + 34000 + imageID * 4);
    dwwrite(0x666778 + 34000 + imageID * 4, new_iscript); // change image iscript
    dwwrite(0x666778 + 14000 + imageID * 1, drawFunc); // change image drawfunc
	SetMemoryX(0x00666458, SetTo, imageID, 0x0000ffff); // change scanner image to input image
    CreateUnit(1, 33, location, playerID);
	RemoveUnit(33, playerID);
	SetMemoryX(0x00666458, SetTo, 546, 0x0000ffff); // revert scanner image
    dwwrite(0x666778 + 34000 + imageID * 4, prev_iscript); // revert image iscript
}

function RedeemUnitExp(playerID, unitType) {
    var amount_players_nearby = 0;
    var exp_to_gain = 0;
    if (unitType == U_CHIMERA) exp_to_gain += 35;
    else if (unitType == U_ANANSI) exp_to_gain += 20;
    else if (unitType == U_HILL_SPINT) exp_to_gain += 80;
    else if (unitType == U_LOST_KNIGHT) exp_to_gain += 500;
    else if (unitType == U_TWISTED_KNIGHT) exp_to_gain += 200;
    if (exp_to_gain == 0) return; // sometimes this function gets accessed without providing anything for unitType argument.
    ResetAuxiliaryArray();
    for (var i = 0; i < 6; i++) {
        aux_array[i] = 0;
        if (i != playerID && GetDistance(p_x[playerID], p_y[playerID], p_x[i], p_y[i]) <= 640) {
            amount_players_nearby += 1;
            aux_array[i] = 1;
        }
    }
    if (amount_players_nearby > 0) {
        exp_to_gain = (exp_to_gain / (amount_players_nearby + 1)) + 1;
        for (var i = 0; i < 6; i++) {
            if (aux_array[i] > 0) p_exp_buffer[i] += exp_to_gain;
        }
    }
    p_exp_buffer[playerID] += exp_to_gain;
}

function RedeemMaterial(playerID, materialID) {
    var amount_gained = 1;
    var amount_total = 0;
    if (materialID == MATERIAL_PLANT_FIBER) {
        p_material_fiber_amount[playerID] += amount_gained;
        amount_total = p_material_fiber_amount[playerID];
    } else if (materialID == MATERIAL_GARTLE_LEAVES) {
        p_material_gartle_amount[playerID] += amount_gained;
        amount_total = p_material_gartle_amount[playerID];
    } else if (materialID == MATERIAL_TARGUS_ROOT) {
        p_material_targus_amount[playerID] += amount_gained;
        amount_total = p_material_targus_amount[playerID];
    } else if (materialID == MATERIAL_WEEPING_HOOD) {
        p_material_hood_amount[playerID] += amount_gained;
        amount_total = p_material_hood_amount[playerID];
    }
    screen.printf("\x12\x04+{} {:s} \x04(Carrying {})\x09\x09", amount_gained, GetStringMaterialName(materialID), amount_total);
}
// @bm DamageUnit
function DamageUnit(playerID, unit: CUnit, damage, index) {
    if (unit.hp == 0 || unit.orderID == 0) return 0;
    var target_state = 1;
    var damage_remaining = damage * 256;
    if (unit.shield > 0) {
        if (unit.shield < damage_remaining) {
            damage_remaining -= unit.shield;
            unit.shield = 0;
        } else {
            unit.shield -= damage_remaining;
            damage_remaining = 0;
        }
    }
    if (unit.hp <= damage_remaining) {
        unit.hp = 0;
    }
	if (unit.hp == 0) {
        if (unit.playerID == $P7 && index < ACTIVE_UNITS_MAX) active_units[index] = 0; // remove from active units array
        if (playerID >= 0 && playerID <= 5) RedeemUnitExp(playerID, unit.unitType);
        unit.die();
        target_state = 0;
    } else {
        unit.hp -= damage_remaining;
    }
    // AGGRO
    if (unit.playerID == $P7 && unit.orderID == 3 && playerID >= 0 && playerID <= 5) { // TODO refactor this later so its more direct using cunit instead of SCs action.
        setloc(L_MAIN, p_x[playerID], p_y[playerID]);
        unit.setloc(L_0X0);
        Order(unit.unitID, $P7, L_0X0, Attack, L_MAIN);
    }
    return target_state;
}

function HealUnit(unit: CUnit, amount, maximum) {
    if (unit.hp + amount >= maximum) unit.hp = maximum;
    else unit.hp += amount;
}

function HealPlayer(playerID, unit: CUnit, amount) {
    if (unit.hp == p_life_max[playerID]) return;
    else if (unit.hp + amount > p_life_max[playerID]) unit.hp = p_life_max[playerID];
    else unit.hp += amount;
}

function HealShieldPlayer(playerID, unit: CUnit, amount) {
    if (unit.shield == p_shield_max[playerID]) return;
    else if (unit.shield + amount > p_shield_max[playerID]) unit.shield = p_shield_max[playerID];
    else unit.shield += amount;
}

function DoMagicLifeDrainCost(playerID, unit: CUnit, amount) {
    if (playerID > 5) return;
    unit.hp -= amount;
    p_life_magic_drained[playerID] += amount;
}

function SCDirectionToDeg(direction) {
    var angle = direction * 14063;
    angle = (angle/10000) - 90; // could make this number readable in the future by keeping it in the range of 0 - 359
    return angle;
}

function GetAngle(originx, originy, destinationx, destinationy) {
    const angle = atan2(destinationy - originy, destinationx - originx);
    return angle;
}

function AddAngles(angle0, angle1) {
    var new_angle = angle0 + angle1;
    if (new_angle > 4000000000) new_angle += 360;
    else if (new_angle >= 360) new_angle -= 360;
    return new_angle;
}

function RotatePosAroundPoint(positionx, positiony, pointx, pointy, rotation) {
    const distance = GetDistance(positionx, positiony, pointx, pointy);
    const new_positionx, new_positiony = MovePosTowards(pointx, pointy, rotation, distance);
    return new_positionx, new_positiony;
}

function Random(min, max) {
   return min + dwrand() / (4294967295 / (max - min + 1) + 1);
}

function PosIsOnMap(positionx, positiony) {
    if (positionx >= 0 && positionx <= 8191 && positiony >= 0 && positiony <= 8191) return 1;
    return 0;
}

function PosToSquare(positionx, positiony, width) {
    const half_width = width/2;
    var limit_left = 0;
    if (positionx > half_width) limit_left = positionx - half_width;
    const limit_right = positionx + half_width;
    var limit_top = 0;
    if (positiony > half_width) limit_top = positiony - half_width;
    const limit_bottom = positiony + half_width;
    return limit_left, limit_right, limit_top, limit_bottom;
}

function ResetHeroPosition(playerID, positionx, positiony) {
    p_x_old[playerID], p_y_old[playerID] = positionx, positiony;
    p_x[playerID], p_y[playerID] = positionx, positiony;
}

function GetSpawnPosition(playerID) {
    if (playerID == 0) return 1984, 1184;
    else if (playerID == 1) return 2048, 1120;
    else if (playerID == 2) return 2128, 1072;
    else if (playerID == 3) return 2192, 1120;
    else if (playerID == 4) return 2144, 1168;
    else if (playerID == 5) return 2080, 1200;
    return 0, 0;
}

function SpawnHero(playerID) {
    if (debug_enabled) p_homepos_x[playerID], p_homepos_y[playerID] = GetLocationPoint(L_PLAYER[playerID]);
    if (p_homepos_x[playerID] == 0) p_homepos_x[playerID], p_homepos_y[playerID] = GetSpawnPosition(playerID);
    if (IsAlive(playerID)) RemoveUnit(U_HERO[playerID], playerID);
    setloc(L_MAIN, p_homepos_x[playerID], p_homepos_y[playerID]);
    p_cunit[playerID] = CreateCUnit(U_HERO[playerID], playerID, L_MAIN);
    CenterView(L_MAIN);
    const unit = CUnit(p_cunit[playerID]);
    ResetHeroPosition(playerID, unit.posX, unit.posY);
}

function SetMaxHP(playerID, value) {
    p_life[playerID] = value;
    p_life_max[playerID] = value;
    const hero = U_HERO[playerID];
    dwwrite_epd(EPD(0x662350) + hero, value);
    ModifyUnitHitPoints(1, hero, playerID, "Anywhere", 100);
}

function CalculateMaxShield(playerID) {
    p_shield_max[playerID] = 0;
    if (p_armor[playerID] == ARMOR_SHATTERED_KNIGHTS) p_shield_max[playerID] += 100 * 256;
}
// @bm EquipItem
function EquipItem(item_id, unitType, playerID) {
    if (unitType == U_WEAPON) {
        weapon_id[playerID] = item_id;
    } else if (unitType == U_UTILITY) {
        utility_id[playerID] = item_id;
    } else if (unitType == U_ARMOR) {
        p_armor[playerID] = item_id;
        CalculateMaxShield(playerID);
    }
}

function SetBeltSlot(itemID, playerID, beltSlot, amount) {
    const slot = (playerID * PLAYER_MAX_BELT_SLOTS) + beltSlot;
    p_belt_equipped[slot] = itemID;
    p_belt_amount[slot] = amount;
}

function EquipBeltSlot(itemID, playerID, beltSlot, amount) {
    const slot = (playerID * PLAYER_MAX_BELT_SLOTS) + beltSlot;
    var new_amount = amount;
    var previous_item_id = p_belt_equipped[slot];
    var previous_amount = p_belt_amount[slot];
    if (previous_item_id == itemID && previous_amount < p_belt_amount_max[playerID]) {
        if (previous_amount + new_amount > p_belt_amount_max[playerID]) { // if the new stack exceeds belt max
            const amount_equipped = p_belt_amount_max[playerID] - previous_amount;
            SetBeltSlot(itemID, playerID, slot, p_belt_amount_max[playerID]);
            previous_amount = (previous_amount + new_amount) - p_belt_amount_max[playerID];
            new_amount = amount_equipped;
        } else { // if the stack is less or equal to belt max
            SetBeltSlot(itemID, playerID, slot, previous_amount + new_amount);
            previous_amount, previous_item_id = 0, 0;
        }
    } else {
        if (new_amount > p_belt_amount_max[playerID]) {
            previous_amount = new_amount - p_belt_amount_max[playerID];
            new_amount = p_belt_amount_max[playerID];
            previous_item_id = itemID;
        }
        SetBeltSlot(itemID, playerID, slot, new_amount);
    }
    return beltSlot + 1, previous_item_id, previous_amount, new_amount;
}

function EquipBeltAvailable(itemID, playerID, amount) {
    var new_amount = amount;
    if (new_amount == 0) new_amount = 1;
    const check_from = playerID * PLAYER_MAX_BELT_SLOTS;
    const check_to = check_from + PLAYER_MAX_BELT_SLOTS;
    var chosen_slot = check_from;
    var slot_number = 1;
    var stacked = 0;
    for (var i = check_from; i < check_to; i++) {
        if (p_belt_unlocked[i]) {
            if (p_belt_equipped[i] == itemID && p_belt_amount[i] < p_belt_amount_max[playerID]) {chosen_slot = i; stacked = 1; break;} // if same item is equipped and not full
            if (p_belt_equipped[i] == 0) {chosen_slot = i; break;} // if its unequipped
            else if (p_belt_amount[i] == 0) {chosen_slot = i; break;} // if its depleted
        }
        slot_number++;
    }
    if (chosen_slot == check_from) slot_number = 1;
    var chosen_equipped = p_belt_equipped[chosen_slot];
    var chosen_amount = p_belt_amount[chosen_slot];
    if (stacked) {
        if (chosen_amount + new_amount > p_belt_amount_max[playerID]) { // if the new stack exceeds belt max
            const amount_equipped = p_belt_amount_max[playerID] - chosen_amount;
            SetBeltSlot(itemID, playerID, chosen_slot, p_belt_amount_max[playerID]);
            chosen_amount = (chosen_amount + new_amount) - p_belt_amount_max[playerID];
            new_amount = amount_equipped;
        } else { // if the stack is less or equal to belt max
            SetBeltSlot(itemID, playerID, chosen_slot, chosen_amount + new_amount);
            chosen_amount, chosen_equipped = 0, 0;
        }
    } else {
        if (new_amount > p_belt_amount_max[playerID]) {
            chosen_amount = new_amount - p_belt_amount_max[playerID];
            new_amount = p_belt_amount_max[playerID];
            chosen_equipped = itemID;
        }
        SetBeltSlot(itemID, playerID, chosen_slot, new_amount);
    }
    return slot_number, chosen_equipped, chosen_amount, new_amount;
    // slot number is the actual number key on the keyboard of the slot that the item was sent to.
    // chosen equipped is the item id of the item that was in the slot previously
    // chosen amount is the amount that was in the slot previously
    // amount equipped is the amount of NEW item equipped.
}

function SetLevelString(playerID) {
    if (IsUserCP()) {
        settblf(1302, 0, "\x04Level \x1F{}\x0C", p_level_current[playerID]);
    }
}

function SetHeroDefaults(playerID) {
    p_level_current[playerID] = 1;
    p_exp_goal[playerID] = 150;
    p_shield_max[playerID] = PLAYER_DEFAULT_SHIELD * 256;
    p_damage[playerID] = PLAYER_DEFAULT_DAMAGE;
    p_attributepoints[playerID] = PLAYER_DEFAULT_ATTRIBUTE;
    SetMaxHP(playerID, PLAYER_DEFAULT_HP * 256);
    SetLevelString(playerID);
    const index = playerID * PLAYER_MAX_BELT_SLOTS;
    p_belt_unlocked[index + 0] = 1;
    p_belt_unlocked[index + 1] = 1;
    p_belt_unlocked[index + 2] = 1;
}

function DrawCircle(positionx, positiony, diameter, dots, imageID, drawFunc, iscript) {
    var angle_increment = (3600000 / dots) / 10000;
    var angle = 0;
    for (var i = 0; i < dots; i++) {
        const x, y = MovePosTowards(positionx, positiony, angle, diameter / 2);
        setloc(L_MAIN, x, y);
        CreateImageSpriteAtLocation($P8, L_MAIN, imageID, drawFunc, iscript);
        angle += angle_increment;
    }
}

function DrawLine(originx, originy, destinationx, destinationy, dots, imageID, drawFunc, iscript) {
    const d = GetDistance(originx, originy, destinationx, destinationy);
    const a = GetAngle(originx, originy, destinationx, destinationy);
    const increment = ((d * 10000) / dots) / 10000;
    for (var i = 0; i < dots; i++) {
        const x, y = MovePosTowards(originx, originy, a, increment * i);
        setloc(L_MAIN, x, y);
        CreateImageSpriteAtLocation($P8, L_MAIN, imageID, drawFunc, iscript);
    }
}

function DrawRect(positionx, positiony, width, height, dots, imageID, drawFunc, iscript) {
    const half_width = width / 2;
    const half_height = height / 2;
    // if (rotation > 0) {
    //     const pos0x, pos0y = RotatePosAroundPoint(positionx - half_width, positiony - half_height, positionx, positiony, 225 + rotation);
    //     const pos1x, pos1y = RotatePosAroundPoint(positionx + half_width, positiony - half_height, positionx, positiony, 315 + rotation);
    //     const pos2x, pos2y = RotatePosAroundPoint(positionx + half_width, positiony + half_height, positionx, positiony, 45 + rotation);
    //     const pos3x, pos3y = RotatePosAroundPoint(positionx - half_width, positiony + half_height, positionx, positiony, 135 + rotation);
    //     DrawLine(pos0x, pos0y, pos1x, pos1y, dots / 4, imageID, drawFunc, iscript);
    //     DrawLine(pos1x, pos1y, pos2x, pos2y, dots / 4, imageID, drawFunc, iscript);
    //     DrawLine(pos2x, pos2y, pos3x, pos3y, dots / 4, imageID, drawFunc, iscript);
    //     DrawLine(pos3x, pos3y, pos0x, pos0y, dots / 4, imageID, drawFunc, iscript);
    // } else {
        DrawLine(positionx - half_width, positiony - half_height, positionx + half_width, positiony - half_height, dots / 4, imageID, drawFunc, iscript);
        DrawLine(positionx + half_width, positiony - half_height, positionx + half_width, positiony + half_height, dots / 4, imageID, drawFunc, iscript);
        DrawLine(positionx + half_width, positiony + half_height, positionx - half_width, positiony + half_height, dots / 4, imageID, drawFunc, iscript);
        DrawLine(positionx - half_width, positiony + half_height, positionx - half_width, positiony - half_height, dots / 4, imageID, drawFunc, iscript);
}

function ClearTextLines(from_line, to_line) {
    for (var i = from_line; i < to_line + 1; i++) {
        DisplayTextAt(i, "\x0BNull");
    }
}

function GetHeight(positionx, positiony) {
    if (!PosIsOnMap(positionx, positiony)) return 0;
    var height = 0;
    setloc(L_MAIN, positionx, positiony);
    MoveUnit(All, U_CHECKHEIGHT, $P12, L_ANYWHERE, L_MAIN);
    MoveLocation(L_HEIGHT0, U_CHECKHEIGHT, $P12, L_ANYWHERE);
    MoveLocation(L_HEIGHT1, U_CHECKHEIGHT, $P12, L_ANYWHERE);
    MoveLocation(L_HEIGHT2, U_CHECKHEIGHT, $P12, L_ANYWHERE);
    if (Bring($P12, AtLeast, 1, U_CHECKHEIGHT, L_HEIGHT0) ) height = 1;
    else if (Bring($P12, AtLeast, 1, U_CHECKHEIGHT, L_HEIGHT1) ) height = 2;
    else if (Bring($P12, AtLeast, 1, U_CHECKHEIGHT, L_HEIGHT2) ) height = 3;
    MoveUnit(All, U_CHECKHEIGHT, $P12, L_ANYWHERE, L_CHECK);
    return height;
}

function PosIsPathable(positionx, positiony, distance_tolerance) {
    const unit = CUnit(cunit_pathable);
    setloc(L_MAIN, positionx, positiony);
    CenterLoc(L_1X1, positionx, positiony);
    MoveUnit(All, U_PATHABLE, $P12, L_ANYWHERE, L_MAIN);
    if (Bring($P12, AtLeast, 1, U_PATHABLE, L_1X1)) {
        MoveUnit(All, U_PATHABLE, $P12, L_ANYWHERE, L_CHECK);
        return 1;
    }
    if (GetDistance(unit.posX, unit.posY, positionx, positiony) <= distance_tolerance) {
        MoveUnit(All, U_PATHABLE, $P12, L_ANYWHERE, L_CHECK);
        return 1;
    }
    MoveUnit(All, U_PATHABLE, $P12, L_ANYWHERE, L_CHECK);
    return 0;
}

function PosHasTerrainCollider(positionx, positiony) {
    setloc(L_MAIN, positionx, positiony);
    MoveUnit(All, U_CHECK_TERRAIN_COLLIDER, $P12, L_ANYWHERE, L_MAIN);
    if (Bring($P12, AtLeast, 1, U_CHECK_TERRAIN_COLLIDER, L_MAIN)) {
        MoveUnit(All, U_CHECK_TERRAIN_COLLIDER, $P12, L_ANYWHERE, L_CHECK);
        return 0;
    }
    MoveUnit(All, U_CHECK_TERRAIN_COLLIDER, $P12, L_ANYWHERE, L_CHECK);
    return 1;
}

function GetChunkID(chunkX, chunkY) {
    // returns a value 1 -> 256, from coordinates 1 -> 256
    if (chunkX > 0 && chunkX <= 16 && chunkY > 0 && chunkY <= 16) {
        return (chunkY - 1) * 16 + chunkX;
    }
    return 0;
}

function GetChunkCoords(chunkID) {
    // returns coordinates 1 -> 256 from an id 1 -> 256
    var chunkx, chunky = 0, 0;
    if (chunkID > 16 && chunkID <= 256) {
        chunkx = ((chunkID - 1) % 16) + 1;
        chunky = ((chunkID - 1) / 16) + 1;
    } else if (chunkID > 0 && chunkID <= 16) {
        chunkx = chunkID;
        chunky = 1;
    }
    return chunkx, chunky;
}

function FillChunkBuffer(chunkX, chunkY) {
    // fills chunk buffer array with ids of the 8 surrounding chunks, ids are zero if not valid like at the edge of the map
    // starts top and goes clockwise.
    for (var i = 0; i < 8; i++) chunk_buffer[i] = 0;
    chunk_buffer[0] = GetChunkID(chunkX, chunkY - 1);
    chunk_buffer[1] = GetChunkID(chunkX + 1, chunkY - 1);
    chunk_buffer[2] = GetChunkID(chunkX + 1, chunkY);
    chunk_buffer[3] = GetChunkID(chunkX + 1, chunkY + 1);
    chunk_buffer[4] = GetChunkID(chunkX, chunkY + 1);
    chunk_buffer[5] = GetChunkID(chunkX - 1, chunkY + 1);
    chunk_buffer[6] = GetChunkID(chunkX - 1, chunkY);
    chunk_buffer[7] = GetChunkID(chunkX - 1, chunkY - 1);
}
// @bm SpawnUnitsAtChunk
function SpawnUnitsAtChunk(chunkX, chunkY) {
    const limit_left = ((chunkX - 1) * 16) * 32;
    const limit_right = limit_left + 512;
    const limit_top = ((chunkY - 1) * 16) * 32;
    const limit_bottom = limit_top + 512;
    for (var i = 0; i < 1000; i++) {
        if (monster_spawn_x[i] >= limit_left && monster_spawn_x[i] < limit_right && monster_spawn_y[i] >= limit_top && monster_spawn_y[i] < limit_bottom) {
            if (monster_spawn_type[i] > 0) {
                const area = GetAreaAtPos(monster_spawn_x[i], monster_spawn_y[i]);
                // skip spawning for some exceptions
                if (area == AREA_CETUS_LAIR && monster_spawn_type[i] == U_LOST_KNIGHT && npc_cetus_exists) continue;
                setloc(L_MAIN, monster_spawn_x[i], monster_spawn_y[i]);
                const new_unit = CreateCUnit(monster_spawn_type[i], $P7, L_MAIN);
                new_unit.unknown0x26 = 0; // set unit physics flag to 0
                if (new_unit.unitID == U_GUARDIAN_ANGEL) {
                    MakeUnitNPC(new_unit, NPC_GUARDIAN_ANGEL);
                    AttachWeaponToUnit(new_unit, WEAPON_ANCIENT_TOME_OF_STARFALL);
                }
                else if (new_unit.unitID == U_TWISTED_KNIGHT) {
                    AttachWeaponToUnit(new_unit, WEAPON_GREATSWORD);
                }
                else if (new_unit.unitID == U_LOST_KNIGHT) {
                    if (area == AREA_CETUS_LAIR) {
                        MakeUnitNPC(new_unit, NPC_CETUS);
                        AttachWeaponToUnit(new_unit, WEAPON_CRIMSON_LONG_SWORD);
                    }
                }
            }
        }
    }
    chunk_spawns[GetChunkID(chunkX, chunkY) - 1] += 1;
}

function JustEnteredChunk(chunkX, chunkY) {
    FillChunkBuffer(chunkX, chunkY);
    // screen.printfAt(8, "{} | {} | {}", chunk_buffer[7], chunk_buffer[0], chunk_buffer[1]);
    // screen.printfAt(9, "{} | -- | {}", chunk_buffer[6], chunk_buffer[2]);
    // screen.printfAt(10, "{} | {} | {}", chunk_buffer[5], chunk_buffer[4], chunk_buffer[3]);
    for (var i = 0; i < 8; i++) {
        if (chunk_buffer[i] > 0 && chunk_spawns[chunk_buffer[i] - 1] == 0) {
            const x, y = GetChunkCoords(chunk_buffer[i]);
            SpawnUnitsAtChunk(x, y);
        }
    }
    if (chunk_spawns[GetChunkID(chunkX, chunkY) - 1] == 0) SpawnUnitsAtChunk(chunkX, chunkY);
}

function GetChunkAtPos(positionx, positiony) {
    var chunk_pos_x = (positionx / 32) / 16;
    var chunk_pos_y = (positiony / 32) / 16;
    return chunk_pos_x + 1, chunk_pos_y + 1;
}

var col_posx = 0;
var col_posy = 0;
var col_enemies = 0;
var col_allies = 0;
var col_pathable = 0; // check if the posx, posy is unpathable.
var col_terrain = 0;
var col_shape = 0; // determines if the check will be for circle or square. Shape only works for units. 
var col_shape_size = 0; // width of the square, or diameter of the circle.
var col_max_results = 0; // should probably increase max results in the future and make it a constant
const col_results_unit = EUDArray(8); // unit pointers
const col_results_unit_activei = EUDArray(8); // index position of the unit in the active units array, this is for deleting it from the active units array if it dies.
var col_results_unit_amount = 0; // keeps track of how many things have been added to the results array
var col_results_pathable = 0;
var col_results_terrain = 0;
function AddUnitToColResults(value, indexfromactive) {
    if (col_results_unit_amount < col_max_results) {
        col_results_unit[col_results_unit_amount] = value;
        col_results_unit_activei[col_results_unit_amount] = indexfromactive;
        col_results_unit_amount++;
        return 0;
    } else {
        return 1;
    } // returns 0 if results are not full, returns 1 if results are full
}

function ResetCheckCollision() {
    col_posx = 0;
    col_posy = 0;
    col_enemies = 0;
    col_allies = 0;
    col_pathable = 0;
    col_terrain = 0;
    col_shape = 0;
    col_shape_size = 0;
    col_max_results = 0;
    for (var i = 0; i < 8; i++) col_results_unit[i] = 0;
    for (var i = 0; i < 8; i++) col_results_unit_activei[i] = 0;
    col_results_unit_amount = 0;
    col_results_pathable = 0;
    col_results_terrain = 0;
}
// @bm CheckCollision
function CheckCollision(playerID) {
    // checks for things according to the configuration of the above vars. use results vars for the results of the check.
    // need to make this check for alliance status
    var result_exists = 0;
    var check_from = 0;
    var check_to = 0;
    if (playerID < 6) {
        check_from = playerID * ACTIVE_UNITS_MAX;
        check_to = check_from + ACTIVE_UNITS_MAX;
    } else {
        check_to = ACTIVE_UNITS_MAX * 6;
    }
    if (col_allies || col_enemies) {
        if (col_shape == 0) {
            const l, r, t, b = PosToSquare(col_posx, col_posy, col_shape_size);
            for (var u = check_from; u < check_to; u++) {
                if (active_units[u] > 0) {
                    const unit = CUnit(active_units[u]);
                    if (col_enemies == 0 && !isAlly(playerID, unit.playerID)) continue;
                    if (col_allies == 0 && isAlly(playerID, unit.playerID)) continue;
                    if (unit.hp > 0 && PosIsWithinRect(unit.posX, unit.posY, l, r, t, b)) {
                        result_exists = 1;
                        const full = AddUnitToColResults(active_units[u], u);
                        if (full) break;
                    }
                }
            }
        } else if (col_shape == 1) {
            for (var u = check_from; u < check_to; u++) {
                if (active_units[u] > 0) {
                    const unit = CUnit(active_units[u]);
                    if (col_enemies == 0 && !isAlly(playerID, unit.playerID)) continue;
                    if (col_allies == 0 && isAlly(playerID, unit.playerID)) continue;
                    if (unit.hp > 0 && GetDistance(unit.posX, unit.posY, col_posx, col_posy) <= col_shape_size / 2) {
                        result_exists = 1;
                        const full = AddUnitToColResults(active_units[u], u);
                        if (full) break;
                    }
                }
            }
        }
    }
    if (col_pathable) {
        if (!PosIsPathable(col_posx, col_posy, col_shape_size)) {
            col_results_pathable = 1;
            result_exists = 1;
        } else col_results_pathable = 0;
    }
    if (col_terrain) {
        if (PosHasTerrainCollider(col_posx, col_posy)) {
            col_results_terrain = 1;
            result_exists = 1;
        } else col_results_terrain = 0;
    }
    return result_exists;
}

// @bm PROJECTILE FUNCTIONS
const PROJECTILE_POOL = 192;
const pro_owner = EUDArray(PROJECTILE_POOL);
const pro_posx = EUDArray(PROJECTILE_POOL);
const pro_posy = EUDArray(PROJECTILE_POOL);
const pro_time = EUDArray(PROJECTILE_POOL);
const pro_maxtime = EUDArray(PROJECTILE_POOL);
const pro_angle = EUDArray(PROJECTILE_POOL);
const pro_velocity = EUDArray(PROJECTILE_POOL);
const pro_angular_velocity = EUDArray(PROJECTILE_POOL);
const pro_orbit = EUDArray(PROJECTILE_POOL);
const pro_orbit_velocity = EUDArray(PROJECTILE_POOL);
const pro_orbit_dist = EUDArray(PROJECTILE_POOL);
const pro_effect0_type = EUDArray(PROJECTILE_POOL); //whether the effect is an image or a unit death
const pro_effect0 = EUDArray(PROJECTILE_POOL);
const pro_effect0_start = EUDArray(PROJECTILE_POOL);
const pro_effect0_drawfunc = EUDArray(PROJECTILE_POOL);
const pro_effect0_iscript = EUDArray(PROJECTILE_POOL);
const pro_effect1_type = EUDArray(PROJECTILE_POOL);
const pro_effect1 = EUDArray(PROJECTILE_POOL);
const pro_effect1_start = EUDArray(PROJECTILE_POOL);
const pro_effect1_drawfunc = EUDArray(PROJECTILE_POOL);
const pro_effect1_iscript = EUDArray(PROJECTILE_POOL);
const pro_effect2_type = EUDArray(PROJECTILE_POOL);
const pro_effect2 = EUDArray(PROJECTILE_POOL);
const pro_effect2_start = EUDArray(PROJECTILE_POOL);
const pro_effect2_drawfunc = EUDArray(PROJECTILE_POOL);
const pro_effect2_iscript = EUDArray(PROJECTILE_POOL);
const pro_anglemod0 = EUDArray(PROJECTILE_POOL);
const pro_anglemod0_start = EUDArray(PROJECTILE_POOL);
const pro_anglemod1 = EUDArray(PROJECTILE_POOL);
const pro_anglemod1_start = EUDArray(PROJECTILE_POOL);
const pro_anglemod2 = EUDArray(PROJECTILE_POOL);
const pro_anglemod2_start = EUDArray(PROJECTILE_POOL);
const pro_weapon_id = EUDArray(PROJECTILE_POOL);
const pro_target_cunit = EUDArray(PROJECTILE_POOL);
const pro_collide_enemies = EUDArray(PROJECTILE_POOL);
const pro_collide_allies = EUDArray(PROJECTILE_POOL);
const pro_collide_terrain = EUDArray(PROJECTILE_POOL);
const pro_collide_shape = EUDArray(PROJECTILE_POOL);
const pro_collide_size = EUDArray(PROJECTILE_POOL);
const pro_collision_pos_x = EUDArray(PROJECTILE_POOL); // these are results that exist after the projectile has collided with something
const pro_collision_pos_y = EUDArray(PROJECTILE_POOL);
const pro_collision_unit = EUDArray(PROJECTILE_POOL);
function ResetProjectile(i) {
    pro_owner[i] = 0;
    pro_time[i] = 0;
    pro_maxtime[i] = 0;
    pro_posx[i] = 0;
    pro_posy[i] = 0;
    pro_angle[i] = 0;
    pro_velocity[i] = 0;
    pro_angular_velocity[i] = 0;
    pro_orbit[i] = 0;
    pro_orbit_velocity[i] = 0;
    pro_orbit_dist[i] = 0;
    pro_effect0_type[i] = 0;
    pro_effect0[i] = 0;
    pro_effect0_start[i] = 0;
    pro_effect0_drawfunc[i] = 0;
    pro_effect0_iscript[i] = 0;
    pro_effect1_type[i] = 0;
    pro_effect1[i] = 0;
    pro_effect1_start[i] = 0;
    pro_effect1_drawfunc[i] = 0;
    pro_effect1_iscript[i] = 0;
    pro_effect2_type[i] = 0;
    pro_effect2[i] = 0;
    pro_effect2_start[i] = 0;
    pro_effect2_drawfunc[i] = 0;
    pro_effect2_iscript[i] = 0;
    pro_anglemod0[i] = 0;
    pro_anglemod0_start[i] = 0;
    pro_anglemod1[i] = 0;
    pro_anglemod1_start[i] = 0;
    pro_anglemod2[i] = 0;
    pro_anglemod2_start[i] = 0;
    pro_weapon_id[i] = 0;
    pro_target_cunit[i] = 0;
    pro_collide_enemies[i] = 0;
    pro_collide_allies[i] = 0;
    pro_collide_terrain[i] = 0;
    pro_collide_shape[i] = 0;
    pro_collide_size[i] = 0;
    pro_collision_pos_x[i] = 0;
    pro_collision_pos_y[i] = 0;
    pro_collision_unit[i] = 0;
}

var queue_pro_owner = 0;
var queue_pro_posx = 0;
var queue_pro_posy = 0;
var queue_pro_time = 0;
var queue_pro_maxtime = 0;
var queue_pro_angle = 0;
var queue_pro_velocity = 0;
var queue_pro_angular_velocity = 0;
var queue_pro_orbit = 0;
var queue_pro_orbit_velocity = 0;
var queue_pro_orbit_dist = 0;
var queue_pro_effect0_type = 0;
var queue_pro_effect0 = 0;
var queue_pro_effect0_start = 0;
var queue_pro_effect0_drawfunc = 0;
var queue_pro_effect0_iscript = 0;
var queue_pro_effect1_type = 0;
var queue_pro_effect1 = 0;
var queue_pro_effect1_start = 0;
var queue_pro_effect1_drawfunc = 0;
var queue_pro_effect1_iscript = 0;
var queue_pro_effect2_type = 0;
var queue_pro_effect2 = 0;
var queue_pro_effect2_start = 0;
var queue_pro_effect2_drawfunc = 0;
var queue_pro_effect2_iscript = 0;
const queue_pro_anglemod = EUDArray(3);
const queue_pro_anglemod_start = EUDArray(3);
var queue_pro_weapon_id = 0;
var queue_pro_target_cunit = 0;
var queue_pro_collide_enemies = 0;
var queue_pro_collide_allies = 0;
var queue_pro_collide_terrain = 0;
var queue_pro_collide_shape = 0;
var queue_pro_collide_size = 0;
function ResetProjectileQueue() {
    queue_pro_owner = 0;
    queue_pro_posx = 0;
    queue_pro_posy = 0;
    queue_pro_time = 0;
    queue_pro_maxtime = 0;
    queue_pro_angle = 0;
    queue_pro_velocity = 0;
    queue_pro_angular_velocity = 0;
    queue_pro_orbit = 0;
    queue_pro_orbit_velocity = 0;
    queue_pro_orbit_dist = 0;
    queue_pro_effect0_type = 0;
    queue_pro_effect0 = 0;
    queue_pro_effect0_start = 0;
    queue_pro_effect0_drawfunc = 0;
    queue_pro_effect0_iscript = 0;
    queue_pro_effect1_type = 0;
    queue_pro_effect1 = 0;
    queue_pro_effect1_start = 0;
    queue_pro_effect1_drawfunc = 0;
    queue_pro_effect1_iscript = 0;
    queue_pro_effect2_type = 0;
    queue_pro_effect2 = 0;
    queue_pro_effect2_start = 0;
    queue_pro_effect2_drawfunc = 0;
    queue_pro_effect2_iscript = 0;
    for (var i = 0; i < 3; i++) {
        queue_pro_anglemod[i] = 0;
        queue_pro_anglemod_start[i] = 0;
    }
    queue_pro_weapon_id = 0;
    queue_pro_target_cunit = 0;
    queue_pro_collide_enemies = 0;
    queue_pro_collide_allies = 0;
    queue_pro_collide_terrain = 0;
    queue_pro_collide_shape = 0;
    queue_pro_collide_size = 0;
}

function CreateProjectile() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_time[i] == 0) {
            pro_owner[i] = queue_pro_owner;
            pro_time[i] = 1;
            pro_maxtime[i] = queue_pro_maxtime + 2;
            pro_posx[i] = queue_pro_posx;
            pro_posy[i] = queue_pro_posy;
            pro_angle[i] = queue_pro_angle;
            pro_velocity[i] = queue_pro_velocity;
            pro_angular_velocity[i] = queue_pro_angular_velocity;
            pro_orbit[i] = queue_pro_angle;
            pro_orbit_velocity[i] = queue_pro_orbit_velocity;
            pro_orbit_dist[i] = queue_pro_orbit_dist;
            pro_effect0_type[i] = queue_pro_effect0_type;
            pro_effect0[i] = queue_pro_effect0;
            pro_effect0_start[i] = queue_pro_effect0_start + 2;
            pro_effect0_drawfunc[i] = queue_pro_effect0_drawfunc;
            pro_effect0_iscript[i] = queue_pro_effect0_iscript;
            pro_effect1_type[i] = queue_pro_effect1_type;
            pro_effect1[i] = queue_pro_effect1;
            pro_effect1_start[i] = queue_pro_effect1_start + 2;
            pro_effect1_drawfunc[i] = queue_pro_effect1_drawfunc;
            pro_effect1_iscript[i] = queue_pro_effect1_iscript;
            pro_effect2_type[i] = queue_pro_effect2_type;
            pro_effect2[i] = queue_pro_effect2;
            pro_effect2_start[i] = queue_pro_effect2_start + 2;
            pro_effect2_drawfunc[i] = queue_pro_effect2_drawfunc;
            pro_effect2_iscript[i] = queue_pro_effect2_iscript;
            pro_anglemod0[i] = queue_pro_anglemod[0];
            pro_anglemod0_start[i] = queue_pro_anglemod_start[0];
            pro_anglemod1[i] = queue_pro_anglemod[1];
            pro_anglemod1_start[i] = queue_pro_anglemod_start[1];
            pro_anglemod2[i] = queue_pro_anglemod[2];
            pro_anglemod2_start[i] = queue_pro_anglemod_start[2];
            pro_weapon_id[i] = queue_pro_weapon_id;
            pro_target_cunit[i] = queue_pro_target_cunit;
            pro_collide_enemies[i] = queue_pro_collide_enemies;
            pro_collide_allies[i] = queue_pro_collide_allies;
            pro_collide_terrain[i] = queue_pro_collide_terrain;
            pro_collide_shape[i] = queue_pro_collide_shape;
            pro_collide_size[i] = queue_pro_collide_size;
            ResetProjectileQueue();
            break;
        }
    }
}
// @bm UpdateProjectiles
function UpdateProjectiles() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_time[i] > 0) {
            pro_time[i] += 1;
            if (pro_time[i] >= pro_anglemod0_start[i] && pro_time[i] < pro_anglemod1_start[i]) pro_angle[i] = AddAngles(pro_angle[i], pro_anglemod0[i]);
            else if (pro_time[i] >= pro_anglemod1_start[i] && pro_time[i] < pro_anglemod2_start[i]) pro_angle[i] = AddAngles(pro_angle[i], pro_anglemod1[i]);
            else if (pro_time[i] >= pro_anglemod2_start[i]) pro_angle[i] = AddAngles(pro_angle[i], pro_anglemod2[i]);
            pro_angle[i] = AddAngles(pro_angle[i], pro_angular_velocity[i]);
            // TARGET CUNIT
            if (pro_target_cunit[i] > 0) {
                const target_unit = CUnit(pro_target_cunit[i]);
                pro_angle[i] = GetAngle(pro_posx[i], pro_posy[i], target_unit.posX, target_unit.posY);
            }

            const new_posx, new_posy = MovePosTowards(pro_posx[i], pro_posy[i], pro_angle[i], pro_velocity[i]);
            pro_posx[i] = new_posx;
            pro_posy[i] = new_posy;

            // CHECK COLLISION
            if (pro_collide_enemies[i] || pro_collide_allies[i] || pro_collide_terrain[i]) {
                col_posx = pro_posx[i];
                col_posy = pro_posy[i];
                col_enemies = pro_collide_enemies[i];
                col_allies = pro_collide_allies[i];
                col_pathable = pro_collide_terrain[i];
                col_shape = pro_collide_shape[i];
                col_shape_size = pro_collide_size[i];
                col_max_results = 1;
                const had_collision = CheckCollision(pro_owner[i]);
                if (had_collision) {
                    pro_collision_pos_x[i], pro_collision_pos_y[i] = pro_posx[i], pro_posy[i];
                    pro_collision_unit[i] = col_results_unit[0];
                }
                ResetCheckCollision();
            }

            pro_orbit[i] = AddAngles(pro_orbit[i], pro_orbit_velocity[i]);
            const offsetx, offsety = MovePosTowards(new_posx, new_posy, pro_orbit[i], pro_orbit_dist[i]);
            setloc(L_MAIN, offsetx, offsety);
            // IMAGES
            if (PosIsOnMap(offsetx, offsety) ) {
                if (pro_effect0[i] > 0 && pro_time[i] >= pro_effect0_start[i] && pro_time[i] < pro_effect1_start[i]) {
                    // time for effect 0
                    if (pro_effect0_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect0[i], pro_effect0_drawfunc[i], pro_effect0_iscript[i]);
                    else CreateUnitDeathAtLocation(pro_effect0[i], $P8, L_MAIN);
                } else if (pro_effect1[i] > 0 && pro_time[i] >= pro_effect1_start[i] && pro_time[i] < pro_effect2_start[i]) {
                    // time for effect 1
                    if (pro_effect1_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect1[i], pro_effect1_drawfunc[i], pro_effect1_iscript[i]);
                    else CreateUnitDeathAtLocation(pro_effect1[i], $P8, L_MAIN);
                } else if (pro_effect2[i] > 0 && pro_time[i] >= pro_effect2_start[i]) {
                    // time for effect 2
                    if (pro_effect2_type[i] == 0) CreateImageSpriteAtLocation($P8, L_MAIN, pro_effect2[i], pro_effect2_drawfunc[i], pro_effect2_iscript[i]);
                    else CreateUnitDeathAtLocation(pro_effect2[i], $P8, L_MAIN);
                }
            }
            if (pro_time[i] >= pro_maxtime[i]) {
                ResetProjectile(i);
            }
        }
    }
}

function UpdateProjectileCollisions() {
    for (var i = 0; i < PROJECTILE_POOL; i++) {
        if (pro_collision_pos_x[i] > 0) {
            // SHORT BOW
            if (pro_weapon_id[i] == WEAPON_SHORTBOW) {
                const damage = GetWeaponDamage(WEAPON_SHORTBOW, 0, pro_owner[i]);
                const target_state = DamageUnit(pro_owner[i], pro_collision_unit[i], damage, ACTIVE_UNITS_MAX + 1);
                setloc(L_MAIN, pro_collision_pos_x[i], pro_collision_pos_y[i]);
                if (target_state) {
                    CreateUnitDeathAtLocation(U_SCOURGE, $P8, L_MAIN);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                } else if (target_state == 0) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_ZERG_AIR_DEATH_SMALL, 0, ISCRIPT_NORMAL);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                }
                ResetProjectile(i);
            }
            // LIGHTNING BLAST
            else if (pro_weapon_id[i] == WEAPON_LIGHTNINGBLAST) {
                const damage = GetWeaponDamage(WEAPON_LIGHTNINGBLAST, 1, pro_owner[i]);
                const target_state = DamageUnit(pro_owner[i], pro_collision_unit[i], damage, ACTIVE_UNITS_MAX + 1);
                setloc(L_MAIN, pro_collision_pos_x[i], pro_collision_pos_y[i]);
                if (target_state) {
                    CreateUnitDeathAtLocation(U_SCOURGE, $P8, L_MAIN);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                } else if (target_state == 0) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_ZERG_AIR_DEATH_SMALL, 0, ISCRIPT_NORMAL);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                }
                ResetProjectile(i);
            }
            // CRIMSON LONG SWORD
            else if (pro_weapon_id[i] == WEAPON_CRIMSON_LONG_SWORD) {
                const target_state = DamageUnit(pro_owner[i], pro_collision_unit[i], 1, ACTIVE_UNITS_MAX + 1);
                pro_collide_enemies[i] = 0;
                pro_collision_pos_x[i] = 0;
                pro_collision_pos_y[i] = 0;
                pro_collision_unit[i] = 0;
            }
            // CRIMSON GREAT BOW
            else if (pro_weapon_id[i] == WEAPON_CRIMSON_GREAT_BOW) {
                const damage = 50;
                const target_state = DamageUnit(pro_owner[i], pro_collision_unit[i], damage, ACTIVE_UNITS_MAX + 1);
                setloc(L_MAIN, pro_collision_pos_x[i], pro_collision_pos_y[i]);
                if (target_state) {
                    CreateUnitDeathAtLocation(U_SCOURGE, $P8, L_MAIN);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                } else if (target_state == 0) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_ZERG_AIR_DEATH_SMALL, 0, ISCRIPT_NORMAL);
                    PlayWAVCP("staredit/wav/hitmarker.ogg", pro_owner[i]);
                }
                ResetProjectile(i);
            }
        }
    }
}

const UNIT_PHYSICS_POOL = 50;
const uphys_time = EUDArray(UNIT_PHYSICS_POOL);
const uphys_cunit = EUDArray(UNIT_PHYSICS_POOL);
const uphys_posx = EUDArray(UNIT_PHYSICS_POOL);
const uphys_posy = EUDArray(UNIT_PHYSICS_POOL);
const uphys_angle = EUDArray(UNIT_PHYSICS_POOL);
const uphys_velocity = EUDArray(UNIT_PHYSICS_POOL);
const uphys_dampening = EUDArray(UNIT_PHYSICS_POOL);
const uphys_dampening_start = EUDArray(UNIT_PHYSICS_POOL);
function ResetUnitPhysics(i) {
    const unit = CUnit(uphys_cunit[i]);
    unit.unknown0x26 = 0;
    uphys_time[i] = 0;
    uphys_cunit[i] = 0;
    uphys_posx[i] = 0;
    uphys_posy[i] = 0;
    uphys_angle[i] = 0;
    uphys_velocity[i] = 0;
    uphys_dampening[i] = 0;
    uphys_dampening_start[i] = 0;
}

var queue_uphys_time = 0;
var queue_uphys_cunit = 0;
var queue_uphys_posx = 0;
var queue_uphys_posy = 0;
var queue_uphys_angle = 0;
var queue_uphys_velocity = 0;
var queue_uphys_dampening = 0;
var queue_uphys_dampening_start = 0;
function ResetUnitPhysicsQueue() {
    queue_uphys_time = 0;
    queue_uphys_cunit = 0;
    queue_uphys_posx = 0;
    queue_uphys_posy = 0;
    queue_uphys_angle = 0;
    queue_uphys_velocity = 0;
    queue_uphys_dampening = 0;
    queue_uphys_dampening_start = 0;
}
// @bm CreateUnitPhysics
function CreateUnitPhysics() {
    const unit = CUnit(queue_uphys_cunit);
    if (unit.unknown0x26 > 0) return;
    for (var i = 0; i < UNIT_PHYSICS_POOL; i++) {
        if (uphys_time[i] == 0) {
            unit.unknown0x26 = 1;
            uphys_time[i] = 1;
            uphys_cunit[i] = queue_uphys_cunit;
            uphys_posx[i] = queue_uphys_posx;
            uphys_posy[i] = queue_uphys_posy;
            uphys_angle[i] = queue_uphys_angle;
            uphys_velocity[i] = queue_uphys_velocity;
            uphys_dampening[i] = queue_uphys_dampening;
            uphys_dampening_start[i] = queue_uphys_dampening_start + 1;
            ResetUnitPhysicsQueue();
            break;
        }
    }
}

function UpdateUnitPhysics() {
    for (var i = 0; i < UNIT_PHYSICS_POOL; i++) {
        if (uphys_time[i] > 0) {
            const unit = CUnit(uphys_cunit[i]);
            if (unit.orderID == 0 || unit.hp == 0 || uphys_cunit[i] == 0) { // delete the index if the unit doesnt exist
                ResetUnitPhysics(i);
                continue;
            }
            // check collision
            col_posx, col_posy = MovePosTowards(unit.posX, unit.posY, uphys_angle[i], uphys_velocity[i]);
            col_terrain = 1;
            col_shape_size = 32;
            const collision_happened = CheckCollision(0);
            if (collision_happened) {
                ResetUnitPhysics(i);
                continue;
            }
            if (uphys_time[i] >= uphys_dampening_start[i]) { // process dampening
                if (uphys_velocity[i] <= uphys_dampening[i]) uphys_velocity[i] = 0;
                else if (uphys_velocity[i] > 0) uphys_velocity[i] -= uphys_dampening[i];
                if (uphys_velocity[i] == 0) {
                    ResetUnitPhysics(i);
                    continue;
                }
            }
            setloc(L_MAIN, unit.posX, unit.posY);
            setloc(L_0X0, col_posx, col_posy);
            uphys_posx[i], uphys_posy[i] = col_posx, col_posy;
            MoveUnit(1, unit.unitID, unit.playerID, L_MAIN, L_0X0);
            ResetCheckCollision();
            uphys_time[i]++;
            if (uphys_time[i] >= 48) ResetUnitPhysics(i);
        }
    }
}

function UpdateTime() {
    time_state_changed = 0;
    time += 1;
    total_time += 1;
    if (time > FULL_DAY_LENGTH) {
        time = 0; 
        time_state = 0;
        time_state_changed = 1;
        days_elapsed += 1;
        DisplayTextAll("\x13\x03--+ The Sun Rises +--");
    } else if (time_state == 0 && time >= FULL_DAY_LENGTH/2) {
        time_state = 1;
        time_state_changed = 1;
        DisplayTextAll("\x13\x1C--+ The Sun Sets +--");
    }
}
// @bm DoDamageAtPos
function DoDamageAtPos(positionx, positiony, playerID, shape, size, damage, maxtargets, damage_type) {
    col_posx, col_posy = positionx, positiony;
    col_enemies = 1;
    col_shape = shape;
    col_shape_size = size;
    col_max_results = maxtargets;
    const result_exists = CheckCollision(playerID);
    if (result_exists) {
        var calculated_damage = damage;
        if (damage_type == 1 && col_results_unit_amount > 1) calculated_damage = damage / col_results_unit_amount;
        for (var result_i = 0; result_i < col_max_results; result_i++) {
            if (col_results_unit[result_i] > 0) {
                const target = CUnit(col_results_unit[result_i]);
                DamageUnit(playerID, target, calculated_damage, col_results_unit_activei[result_i]);
            }
        }
    }
    ResetCheckCollision();
}

var fow_state;
function UpdateFOW() {
    if (fow_state == 0) {
        fow_state = 1;
        SetMemory(0x0051CE98, SetTo, 0);
    } else {
        fow_state = 0;
        SetMemory(0x0051CE98, SetTo, 1);
    }
}

function UpdateSigils() {
    for (var i = 0; i < MAX_SIGIL_SPAWNS; i++) {
        if (sigil_x[i] > 0) {
            var player_on_sigil = 0;
            for (var p = 0; p < 6; p++) {
                if (p_current_sigil[p] == i && p_on_sigil[p] > 0) {
                    player_on_sigil = 1;
                    break;
                }
            }
            if (player_on_sigil) {
                sigil_glow[i]++;
                if (sigil_glow[i] >= 24) {
                    DrawCircle(sigil_x[i], sigil_y[i], SIGIL_DIAMETER, 24, 443, 0, ISCRIPT_NORMAL);
                    sigil_glow[i] = 0;
                }
            } else sigil_glow[i] = 0;
        }
    }
}

function UpdateBrightness(playerID) {
    var target_brightness = BRIGHTNESS_DEFAULT;
    if (time_state == 1) target_brightness = BRIGHTNESS_NIGHT;
    if (p_indoors[playerID]) target_brightness -= 6;
    if (utility_id[playerID] == UTILITY_TORCH && target_brightness < BRIGHTNESS_DEFAULT) target_brightness = BRIGHTNESS_DEFAULT;
    if (p_brightness[playerID] < target_brightness) p_brightness[playerID] += 1;
    else if (p_brightness[playerID] > target_brightness) p_brightness[playerID] -= 1;
    if (IsUserCP()) SetMemoryEPD(EPD(0x657A9C), SetTo, p_brightness[playerID]);
}

function UpdateSightRange(playerID) {
    var target_value = PLAYER_DEFAULT_SIGHT;
    if (time_state == 1) target_value = PLAYER_DEFAULT_SIGHT - 4;
    if (p_indoors[playerID] && time_state == 0) target_value = 2;
    else if (p_indoors[playerID]) target_value = 1;
    if (utility_id[playerID] == UTILITY_TORCH && target_value < PLAYER_DEFAULT_SIGHT - 4) target_value = PLAYER_DEFAULT_SIGHT - 4;
    if (GetAreaAtPos(p_x[playerID], p_y[playerID]) == AREA_CETUS_LAIR) target_value = PLAYER_DEFAULT_SIGHT;
    bwrite(0x65FD00 + 13624 + U_HERO[playerID] * 1, target_value);
}

function UpdateSigilMenu(playerID) {
    if (keypress_1[playerID] && p_attributepoints[playerID] > 0) {
        p_strength[playerID]++;
        p_attributepoints[playerID]--;
        CalculateKnightSwordDamage(playerID);
        for (var i = 0; i < 8; i++) {
            queue_pro_posx = p_x[playerID];
            queue_pro_posy = p_y[playerID];
            queue_pro_maxtime = 5;
            queue_pro_angle = (i + 1) * 45;
            queue_pro_velocity = 20;
            queue_pro_effect2 = 450;
            queue_pro_effect2_start = 3;
            CreateProjectile();
        }
        PlayWAV("staredit/wav/increase_attribute.ogg");
        PlayWAV("sound/Bullet/ZLrkHit2.wav");
    }
    if (keypress_2[playerID] && p_attributepoints[playerID] > 0) {
        p_dexterity[playerID]++;
        p_attributepoints[playerID]--;
        for (var i = 0; i < 8; i++) {
            queue_pro_posx = p_x[playerID];
            queue_pro_posy = p_y[playerID];
            queue_pro_maxtime = 5;
            queue_pro_angle = (i + 1) * 45;
            queue_pro_velocity = 20;
            queue_pro_effect2 = 505;
            queue_pro_effect2_start = 3;
            CreateProjectile();
        }
        PlayWAV("staredit/wav/increase_attribute.ogg");
        PlayWAV("sound/Bullet/ZLrkHit2.wav");
    }
    if (keypress_3[playerID] && p_attributepoints[playerID] > 0) {
        p_resilience[playerID]++;
        p_attributepoints[playerID]--;
        for (var i = 0; i < 8; i++) {
            queue_pro_posx = p_x[playerID];
            queue_pro_posy = p_y[playerID];
            queue_pro_maxtime = 5;
            queue_pro_angle = (i + 1) * 45;
            queue_pro_velocity = 20;
            queue_pro_effect2 = 466;
            queue_pro_effect2_start = 3;
            CreateProjectile();
        }
        PlayWAV("staredit/wav/increase_attribute.ogg");
        PlayWAV("sound/Bullet/ZLrkHit2.wav");
    }
    screen.printfAt(0, "\x09\x09\x09\x11.STRENGTH \x1F({})\x09\x09\x09\x09\x07.DEXTERITY \x1F({})\x09\x09\x09\x09\x1C.RESILIENCE \x1F({})", p_strength[playerID], p_dexterity[playerID], p_resilience[playerID]);
    DisplayTextAt(1, "\x09\x09\x09\x03.Press -<1>- to Allocate\x09\x09\x03.Press -<2>- to Allocate\x09\x09\x03.Press -<3>- to Allocate");
    DisplayTextAt(2, "\x09\x09\x09\x11|\x04Sword Effectiveness\x09\x09\x07|\x04Bow Effectiveness\x09\x09\x09\x1C|\x04Magic Effectiveness");
    DisplayTextAt(3, "\x09\x09\x09\x11|\x04Life Regeneration\x09\x09\x09\x07|\x04Life Toughness\x09\x09\x09\x09\x1C|\x04Armor Toughness");
    DisplayTextAt(4, "\x09\x09\x09\x11|\x04Something\x09\x09\x09\x09\x09\x07|\x04Attack Speed\x09\x09\x09\x09\x1C|\x04Life Drain Recovery");
    DisplayTextAt(5, "\x0BNull");
    screen.printfAt(6, "\x09\x09\x09\x04Available Attribute Points: \x1F{}", p_attributepoints[playerID]);
}

function PlayerHasCraftingIngredients(playerID, itemID, itemUnitID) {
    var insufficient0 = 0;
    var insufficient1 = 0;
    var insufficient2 = 0;
    var insufficient3 = 0;
    var has_ingredients = 0;
    if (itemUnitID == U_CONSUMABLE) {
        if (itemID == CONSUMABLE_BANDAGE) {
            if (p_material_fiber_amount[playerID] < 2) insufficient0 = MATERIAL_PLANT_FIBER;
        } else if (itemID == CONSUMABLE_ELIXER_OF_LIFE) {
            if (p_material_fiber_amount[playerID] < 1) insufficient0 = MATERIAL_PLANT_FIBER;
            if (p_material_gartle_amount[playerID] < 2) insufficient1 = MATERIAL_GARTLE_LEAVES;
        } else if (itemID == CONSUMABLE_FUSE_BOMB) {
            if (p_material_fiber_amount[playerID] < 2) insufficient0 = MATERIAL_PLANT_FIBER;
            if (p_material_iron_amount[playerID] < 1) insufficient1 = MATERIAL_IRON_ORE;
            if (p_material_targus_amount[playerID] < 1) insufficient2 = MATERIAL_TARGUS_ROOT;
        }
    }
    if (insufficient0 == 0 && insufficient1 == 0 && insufficient2 == 0 && insufficient3 == 0) has_ingredients = 1;
    return has_ingredients, insufficient0, insufficient1, insufficient2, insufficient3;
}

function UpdateCraftingMenu(playerID) {
    // get input
    if (keypress_1[playerID]) {
        ResetAuxiliaryArray();
        aux_array[0], aux_array[1], aux_array[2], aux_array[3], aux_array[4] = PlayerHasCraftingIngredients(playerID, CONSUMABLE_BANDAGE, U_CONSUMABLE);
        if (aux_array[0] > 0) {
            p_material_fiber_amount[playerID] -= 2;
            setloc(L_MAIN, p_x[playerID], p_y[playerID]);
            CreateItemUnit(U_CONSUMABLE, CONSUMABLE_BANDAGE, L_MAIN, 0, 1);
        } else {
            for (var i = 1; i < 5; i++) {
                if (aux_array[i] > 0) screen.printf("\x13\x04Insufficient {:s}", GetStringMaterialName(aux_array[i]));
            }
        }
    }
    // check for ingredients
    // display missing ingredients
    // craft if all the ingredients are present
    // create the item unit
    DisplayTextAt(0, "\x09\x09\x09\x04CRAFTING --");
    screen.printfAt(1, "\x09\x09\x09\x03-<1>- \x04{:s} - \x02{:s} {:s}", GetStringItemName(CONSUMABLE_BANDAGE, U_CONSUMABLE), GetStringItemDescription(CONSUMABLE_BANDAGE, U_CONSUMABLE), GetStringIngredients(CONSUMABLE_BANDAGE, U_CONSUMABLE));
    screen.printfAt(2, "\x09\x09\x09\x03-<2>- \x04{:s} - \x02{:s} {:s}", GetStringItemName(CONSUMABLE_ELIXER_OF_LIFE, U_CONSUMABLE), GetStringItemDescription(CONSUMABLE_ELIXER_OF_LIFE, U_CONSUMABLE), GetStringIngredients(CONSUMABLE_ELIXER_OF_LIFE, U_CONSUMABLE));
    screen.printfAt(3, "\x09\x09\x09\x03-<3>- \x04{:s} - \x02{:s} {:s}", GetStringItemName(CONSUMABLE_FUSE_BOMB, U_CONSUMABLE), GetStringItemDescription(CONSUMABLE_FUSE_BOMB, U_CONSUMABLE), GetStringIngredients(CONSUMABLE_FUSE_BOMB, U_CONSUMABLE));
}

function ResetWeaponIndex(index) {
    weapon_cunit[index] = 0;
    weapon_id[index] = 0;
    weapon_state[index] = 0;
    weapon_cooldown[index] = 0;
    weapon_angle[index] = 0;
    weapon_x[index] = 0;
    weapon_y[index] = 0;
}
// @bm UpdateWeaponState
function UpdateWeaponState(playerID) {
    var check_from = 0;
    var check_to = 0;
    if (playerID < 6) {
        check_from = playerID;
        check_to = playerID + 1;
    } else if (playerID == $P7) {
        check_from = 6;
        check_to = MAX_WEAPON_OBJECTS;
    }
    for (var weapon_index = check_from; weapon_index < check_to; weapon_index++) {
        const i = weapon_index;
        if (weapon_id[i] > 0) {
            var unit_ptr = weapon_cunit[i]; // set unit to whatever the weapon id is attached to
            var is_player = 0;
            var unit_just_attacked = 0;
            var unit_x = 0;
            var unit_y = 0;
            var unit_order_x = 0;
            var unit_order_y = 0;
            var unit_angle = 0;
            var display_damage = 0;
            if (i >= 0 && i <= 5) {unit_ptr = p_cunit[i]; is_player = 1;} // set unit to players unit if its a player
            const unit = CUnit(unit_ptr);
            if (is_player) {
                unit_just_attacked = p_just_attacked[i];
                unit_x = p_x[i];
                unit_y = p_y[i];
                unit_order_x = p_orderx[i];
                unit_order_y = p_ordery[i];
                unit_angle = p_angle[i];
            } else if (playerID == $P7) {
                if (unit.hp == 0) {
                    ResetWeaponIndex(i);
                    continue;
                }
                unit_x = unit.posX;
                unit_y = unit.posY;
                unit_order_x = unit.orderTargetX;
                unit_order_y = unit.orderTargetY;
                unit_angle = SCDirectionToDeg(unit.currentDirection1);
            }

            // TRIGGER
            if (weapon_cooldown[i] > 0) weapon_cooldown[i]--;
            var weapon_triggered = CheckForWeaponTrigger(playerID, unit, weapon_id[i]);
            if (weapon_triggered && weapon_cooldown[i] == 0) {
                weapon_cooldown[i] = GetWeaponCooldown(weapon_id[i], playerID);
                weapon_state[i] = 1;
            }

            // SHORT SWORD
            if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_SHORTSWORD) {
                if (weapon_state[i] == 1) {
                    const damage = GetWeaponDamage(weapon_id[i], weapon_state[i], playerID);
                    weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, unit_angle, 32);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 128, damage, 2, 0);
                    weapon_angle[i] = unit_angle + 60;
                    PlaySword();
                    display_damage = damage;
                }
                if (weapon_state[i] > 0) {
                    queue_pro_posx = unit_x;
                    queue_pro_posy = unit_y;
                    queue_pro_maxtime = 3;
                    queue_pro_angle = weapon_angle[i];
                    queue_pro_velocity = 10;
                    queue_pro_effect1 = 424;
                    queue_pro_effect1_iscript = ISCRIPT_FAST;
                    queue_pro_effect2 = 213;
                    queue_pro_effect2_start = 2;
                    queue_pro_effect2_iscript = ISCRIPT_FAST;
                    CreateProjectile();
                    weapon_angle[i] -= 20;
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 6) weapon_state[i] = 0;
            }

            // LONG SWORD
            else if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_LONGSWORD) {
                if (weapon_state[i] == 1) {
                    const damage = GetWeaponDamage(weapon_id[i], weapon_state[i], playerID);
                    weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, unit_angle, 32);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 128, damage, 4, 0);
                    weapon_angle[i] = unit_angle + 90;
                    PlaySword();
                    display_damage = damage;
                }
                if (weapon_state[i] > 0) {
                    for (var j = 0; j < 2; j++) {
                        queue_pro_posx = unit_x;
                        queue_pro_posy = unit_y;
                        queue_pro_maxtime = 3;
                        queue_pro_angle = weapon_angle[i];
                        queue_pro_velocity = 18;
                        queue_pro_effect1 = IMAGE_PHOTON_BLASTERS;
                        queue_pro_effect1_drawfunc = 17;
                        queue_pro_effect1_iscript = ISCRIPT_FAST;
                        queue_pro_effect2 = IMAGE_ZERG_AIR_DEATH_SMALL;
                        queue_pro_effect2_drawfunc = 16;
                        queue_pro_effect2_start = 3;
                        queue_pro_effect2_iscript = ISCRIPT_FAST;
                        CreateProjectile();
                        weapon_angle[i] -= 22;
                    }
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 5) weapon_state[i] = 0;
            }

            // GREAT SWORD
            else if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_GREATSWORD) {
                if (weapon_state[i] == 1) {
                    const damage = GetWeaponDamage(weapon_id[i], weapon_state[i], playerID);
                    weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, unit_angle, 48);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 176, damage, 8, 0);
                    weapon_angle[i] = AddAngles(unit_angle, 90);
                    PlaySword();
                    display_damage = damage;
                }
                if (weapon_state[i] > 0) {
                    for (var j = 0; j < 2; j++) {
                        queue_pro_posx = unit_x;
                        queue_pro_posy = unit_y;
                        queue_pro_maxtime = 3;
                        queue_pro_angle = weapon_angle[i];
                        queue_pro_velocity = 18;
                        queue_pro_effect0_start = 1;
                        queue_pro_effect0 = IMAGE_BURST_LASER;
                        queue_pro_effect0_drawfunc = 17;
                        queue_pro_effect0_iscript = ISCRIPT_FAST;
                        queue_pro_effect1_start = 2;
                        queue_pro_effect1 = IMAGE_NEUTRON;
                        queue_pro_effect1_drawfunc = 17;
                        queue_pro_effect1_iscript = ISCRIPT_FAST;
                        queue_pro_effect2 = IMAGE_EXPL_BLUE_SMALL;
                        queue_pro_effect2_start = 3;
                        queue_pro_effect2_iscript = ISCRIPT_FAST;
                        CreateProjectile();
                        // knockback
                        col_posx, col_posy = MovePosTowards(unit_x, unit_y, weapon_angle[i], 24);
                        col_enemies = 1;
                        col_max_results = 4;
                        col_shape = 0;
                        col_shape_size = 32;
                        const collision_happened = CheckCollision(playerID);
                        if (collision_happened) {
                            for (var cu = 0; cu < 8; cu++) {
                                if (col_results_unit[cu] > 0) {
                                    const found_unit = CUnit(col_results_unit[cu]);
                                    queue_uphys_cunit = col_results_unit[cu];
                                    queue_uphys_posx, queue_uphys_posy = found_unit.posX, found_unit.posY;
                                    queue_uphys_angle = weapon_angle[i];
                                    queue_uphys_velocity = 25;
                                    queue_uphys_dampening = 4;
                                    queue_uphys_dampening_start = 1;
                                    CreateUnitPhysics();
                                }
                            }
                        }
                        ResetCheckCollision();
                        weapon_angle[i] = AddAngles(weapon_angle[i], -22);
                    }
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 5) weapon_state[i] = 0;
            }

            // SHORT BOW
            else if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_SHORTBOW) {
                if (weapon_state[i] == 1) {
                    CenterLoc(L_4X4, unit_x, unit_y);
                    if (EnemiesAtLoc(L_4X4)) weapon_state[i] = 0;
                    else {
                        weapon_x[i], weapon_y[i] = unit_order_x, unit_order_y;
                        PlayWAV("staredit/wav/bow_charge.ogg");
                    }
                }
                if (weapon_state[i] > 0 && weapon_state[i] <= 10) {
                    const distance = 66 - (weapon_state[i] * 6);
                    const angle_to_order = GetAngle(unit_x, unit_y, weapon_x[i], weapon_y[i]);
                    const image0_x, image0_y = MovePosTowards(unit_x, unit_y, angle_to_order + 70, distance);
                    const image1_x, image1_y = MovePosTowards(unit_x, unit_y, angle_to_order - 70, distance);
                    const image2_x, image2_y = MovePosTowards(unit_x, unit_y, angle_to_order, distance);
                    setloc(L_MAIN, image0_x, image0_y);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 233, 16, ISCRIPT_NORMAL);
                    setloc(L_MAIN, image1_x, image1_y);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 233, 16, ISCRIPT_NORMAL);
                    setloc(L_MAIN, image2_x, image2_y);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 233, 16, ISCRIPT_NORMAL);
                }
                if (weapon_state[i] == 11) {
                    const angle_to_order = GetAngle(unit_x, unit_y, weapon_x[i], weapon_y[i]);
                    queue_pro_owner = playerID;
                    queue_pro_weapon_id = weapon_id[i];
                    queue_pro_posx = unit_x;
                    queue_pro_posy = unit_y;
                    queue_pro_maxtime = 24;
                    queue_pro_angle = angle_to_order;
                    queue_pro_velocity = 40;
                    queue_pro_effect1 = 557;
                    queue_pro_effect1_start = 3;
                    queue_pro_effect2 = 441;
                    queue_pro_effect2_drawfunc = 16;
                    queue_pro_effect2_start = 4;
                    queue_pro_collide_enemies = 1;
                    queue_pro_collide_size = 64;
                    CreateProjectile();
                    for (var j = 0; j < 3; j++) {
                        queue_pro_posx = unit_x;
                        queue_pro_posy = unit_y;
                        queue_pro_maxtime = 6;
                        queue_pro_angle = angle_to_order;
                        queue_pro_velocity = 35;
                        queue_pro_angular_velocity = Random(-20, 20);
                        queue_pro_effect1 = 422;
                        queue_pro_effect1_drawfunc = 17;
                        queue_pro_effect2_start = queue_pro_maxtime;
                        queue_pro_effect2 = 422; // 495, 544, 963, 512
                        queue_pro_effect2_drawfunc = 12;
                        CreateProjectile();
                    }
                    PlayArrow();
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 13) weapon_state[i] = 0;
            }

            // FIRE BALL
            else if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_FIREBALL) {
                const life_cost = GetWeaponLifeCost(weapon_id[i], playerID);
                if (weapon_state[i] == 1 && unit.hp > life_cost) {
                    DoMagicLifeDrainCost(playerID, unit, life_cost);
                } else if (weapon_state[i] == 1) {
                    weapon_state[i] = 0;
                }
                if (weapon_state[i] == 1) {
                    const angle_to_order = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    const distance_to_order = GetDistance(unit_x, unit_y, unit_order_x, unit_order_y);
                    if (distance_to_order > 256) weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, angle_to_order, 256);
                    else weapon_x[i], weapon_y[i] = unit_order_x, unit_order_y;
                    queue_pro_posx, queue_pro_posy = MovePosTowards(weapon_x[i], weapon_y[i], 280, 366);
                    queue_pro_maxtime = 20;
                    queue_pro_angle = 100;
                    queue_pro_velocity = 20;
                    queue_pro_effect1 = 332;
                    queue_pro_effect1_start = 0;
                    queue_pro_effect2 = 333;
                    queue_pro_effect2_start = queue_pro_maxtime;
                    CreateProjectile();
                    PlayWavAtPos("staredit/wav/fireball_incoming.ogg", weapon_x[i], weapon_y[i], 512);
                    DrawCircle(weapon_x[i], weapon_y[i], 128, 24, 448, 0, ISCRIPT_NORMAL);
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 20) {
                    weapon_state[i] = 0;
                    const damage = GetWeaponDamage(weapon_id[i], weapon_state[i], playerID);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 128, damage, 8, 0);
                    setloc(L_MAIN, weapon_x[i], weapon_y[i]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 429, 0, ISCRIPT_LONGFAST);
                    PlayWavAtPos("staredit/wav/fireball.ogg", weapon_x[i], weapon_y[i], 512);
                    display_damage = damage;
                }
            }

            // LIGHTNING BLAST
            else if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_LIGHTNINGBLAST) {
                const life_cost = GetWeaponLifeCost(weapon_id[i], playerID);
                if (weapon_state[i] == 1 && unit.hp > life_cost) {
                    DoMagicLifeDrainCost(playerID, unit, life_cost);
                } else if (weapon_state[i] == 1) {
                    weapon_state[i] = 0;
                }
                if (weapon_state[i] == 1) {
                    weapon_angle[i] = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, weapon_angle[i], 32);
                    DrawCircle(weapon_x[i], weapon_y[i], 96, 20, 435, 16, ISCRIPT_NORMAL);
                    PlayWavAtPos("sound\Bullet\zdeAtt00.wav", weapon_x[i], weapon_y[i], 512);
                }
                if (weapon_state[i] == 20) {
                    const damage = GetWeaponDamage(weapon_id[i], 0, playerID);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 96, damage, 8, 1);
                    display_damage = damage;
                    setloc(L_MAIN, weapon_x[i], weapon_y[i]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_LIGHTNING_STORM, 0, ISCRIPT_NORMAL);
                    DrawCircle(weapon_x[i], weapon_y[i], 80, 20, IMAGE_GAUSS_RIFLE_HIT, 16, ISCRIPT_GAUSS_RIFLE_HIT);
                    const iterations = 1;
                    var current_parameter_set = Random(0, 3);
                    for (var j = 0; j < iterations; j++) {
                        queue_pro_owner = playerID;
                        queue_pro_weapon_id = weapon_id[i];
                        queue_pro_posx, queue_pro_posy = weapon_x[i], weapon_y[i];
                        queue_pro_maxtime = 8;
                        queue_pro_angle = weapon_angle[i] + Random(-30, 30);
                        queue_pro_velocity = 60;
                        queue_pro_effect0 = IMAGE_LIGHTNING0;
                        queue_pro_effect0_start = 0;
                        queue_pro_effect1 = IMAGE_LIGHTNING1;
                        queue_pro_effect1_start = 4;
                        queue_pro_effect2 = IMAGE_LIGHTNING2;
                        queue_pro_effect2_start = queue_pro_maxtime;
                        if (current_parameter_set == 0) {
                            queue_pro_anglemod[0] = 30  + Random(-5, 5);
                            queue_pro_anglemod[1] = -30 + Random(-5, 5);
                            queue_pro_anglemod[2] = 30 + Random(-5, 5);
                        } else if (current_parameter_set == 1) {
                            queue_pro_anglemod[0] = -30  + Random(-5, 5);
                            queue_pro_anglemod[1] = 30 + Random(-5, 5);
                            queue_pro_anglemod[2] = -30 + Random(-5, 5);
                        } else if (current_parameter_set == 2) {
                            queue_pro_anglemod[0] = 10  + Random(-5, 5);
                            queue_pro_anglemod[1] = -50 + Random(-5, 5);
                            queue_pro_anglemod[2] = 25 + Random(-5, 5);
                        } else if (current_parameter_set == 3) {
                            queue_pro_anglemod[0] = -15  + Random(-5, 5);
                            queue_pro_anglemod[1] = 55 + Random(-5, 5);
                            queue_pro_anglemod[2] = -25 + Random(-5, 5);
                        }
                        queue_pro_anglemod_start[0] = 2;
                        queue_pro_anglemod_start[1] = 4;
                        queue_pro_anglemod_start[2] = 6;
                        queue_pro_collide_enemies = 1;
                        queue_pro_collide_size = 64;
                        CreateProjectile();
                        current_parameter_set++;
                        if (current_parameter_set > 3) current_parameter_set = 0;
                    }
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 21) {
                    weapon_state[i] = 0;
                }
            }

            // ANCIENT TOME OF STAR FALL
            else if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_ANCIENT_TOME_OF_STARFALL) {
                const life_cost = GetWeaponLifeCost(weapon_id[i], playerID);
                if (weapon_state[i] == 1 && unit.hp > life_cost) {
                    DoMagicLifeDrainCost(playerID, unit, life_cost);
                } else if (weapon_state[i] == 1) {
                    weapon_state[i] = 0;
                }
                if (weapon_state[i] == 1) {
                    const angle_to_order = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    const distance_to_order = GetDistance(unit_x, unit_y, unit_order_x, unit_order_y);
                    if (distance_to_order > 640) weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, angle_to_order, 640);
                    else weapon_x[i], weapon_y[i] = unit_order_x, unit_order_y;
                    queue_pro_posx, queue_pro_posy = MovePosTowards(weapon_x[i], weapon_y[i], 280, 366);
                    queue_pro_maxtime = 20;
                    queue_pro_angle = 100;
                    queue_pro_velocity = 20;
                    queue_pro_effect1 = 213;
                    queue_pro_effect1_start = 0;
                    queue_pro_effect2 = 214;
                    queue_pro_effect2_start = queue_pro_maxtime;
                    CreateProjectile();
                    PlayWavAtPos("staredit/wav/fireball_incoming.ogg", weapon_x[i], weapon_y[i], 512);
                    DrawCircle(weapon_x[i], weapon_y[i], 192, 36, 448, 16, ISCRIPT_NORMAL);
                }
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 20) {
                    weapon_state[i] = 0;
                    const damage = GetWeaponDamage(weapon_id[i], weapon_state[i], playerID);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 192, damage, 8, 0);
                    setloc(L_MAIN, weapon_x[i], weapon_y[i]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, 444, 0, ISCRIPT_LONGFAST);
                    PlayWavAtPos("staredit/wav/fireball.ogg", weapon_x[i], weapon_y[i], 512);
                    display_damage = damage;
                    for (var j = 0; j < 8; j++) {
                        queue_pro_posx = weapon_x[i];
                        queue_pro_posy = weapon_y[i];
                        queue_pro_maxtime = 8;
                        queue_pro_angle = (j + 1) * 45;
                        queue_pro_velocity = 30;
                        queue_pro_angular_velocity = Random(-10, 10);
                        queue_pro_effect1 = 448;
                        queue_pro_effect1_drawfunc = 16;
                        queue_pro_effect2 = 427;
                        queue_pro_effect2_drawfunc = 16;
                        queue_pro_effect2_start = queue_pro_maxtime;
                        CreateProjectile();
                    }
                }
            }

            // CRIMSON LONG SWORD
            else if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_CRIMSON_LONG_SWORD) {
                if (weapon_state[i] == 1) weapon_x[i], weapon_y[i] = unit_x, unit_y;
                // warn
                if (weapon_state[i] > 0 && weapon_state[i] < 12) {
                    const effect_d = 192 - (weapon_state[i] * 17);
                    var visual_amount = 24;
                    if (effect_d > 128) visual_amount = 24;
                    else if (effect_d > 64) visual_amount = 20;
                    else if (effect_d > 32) visual_amount = 16;
                    else if (effect_d > 16) visual_amount = 12;
                    else if (effect_d > 1) visual_amount = 1;
                    if (visual_amount > 1) DrawCircle(weapon_x[i], weapon_y[i], effect_d, visual_amount, IMAGE_NUKE_DOT, 17, ISCRIPT_NORMAL);
                }
                if (weapon_state[i] == 12) weapon_angle[i] = unit_angle + 90;
                else if (weapon_state[i] == 19) weapon_angle[i] = unit_angle - 90;
                if (weapon_state[i] == 13) {
                    weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, unit_angle, 32);
                    const damage = GetWeaponDamage(weapon_id[i], 0, playerID);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 128, 50, 5, 0);
                    PlayWavAtPos("staredit/wav/large_sword0.ogg", unit_x, unit_y, 512);
                } else if (weapon_state[i] == 20) {
                    weapon_x[i], weapon_y[i] = MovePosTowards(unit_x, unit_y, unit_angle, 32);
                    const damage = GetWeaponDamage(weapon_id[i], 0, playerID);
                    DoDamageAtPos(weapon_x[i], weapon_y[i], playerID, 1, 128, 60, 5, 0);
                    PlayWavAtPos("staredit/wav/large_sword0.ogg", unit_x, unit_y, 512);
                }
                // swing 1
                if (weapon_state[i] >= 12 && weapon_state[i] <= 15) {
                    for (var j = 0; j < 2; j++) {
                        queue_pro_posx = unit_x;
                        queue_pro_posy = unit_y;
                        queue_pro_maxtime = 3;
                        queue_pro_angle = weapon_angle[i];
                        queue_pro_velocity = 18;
                        queue_pro_effect1 = IMAGE_NUKE_DEATH;
                        queue_pro_effect1_drawfunc = 17;
                        queue_pro_effect1_iscript = ISCRIPT_FAST;
                        queue_pro_effect2 = IMAGE_ZERG_AIR_DEATH_LARGE;
                        queue_pro_effect2_start = 3;
                        queue_pro_effect2_iscript = ISCRIPT_FAST;
                        CreateProjectile();
                        weapon_angle[i] -= 22;
                    }
                } else if (weapon_state[i] >= 19 && weapon_state[i] <= 22) {
                    for (var j = 0; j < 2; j++) {
                        queue_pro_owner = playerID;
                        queue_pro_weapon_id = weapon_id[i];
                        queue_pro_collide_enemies = 1;
                        queue_pro_collide_size = 48;
                        queue_pro_posx = unit_x;
                        queue_pro_posy = unit_y;
                        queue_pro_maxtime = 5;
                        queue_pro_angle = weapon_angle[i];
                        queue_pro_velocity = 18;
                        queue_pro_effect0 = IMAGE_NUKE_DEATH;
                        queue_pro_effect0_drawfunc = 17;
                        queue_pro_effect0_iscript = ISCRIPT_FAST;
                        queue_pro_effect1 = IMAGE_ZERG_AIR_DEATH_LARGE;
                        queue_pro_effect1_start = 4;
                        queue_pro_effect1_drawfunc = 17;
                        queue_pro_effect1_iscript = ISCRIPT_FAST;
                        queue_pro_effect2 = IMAGE_ZERG_AIR_DEATH_LARGE;
                        queue_pro_effect2_start = 5;
                        queue_pro_effect2_iscript = ISCRIPT_FAST;
                        CreateProjectile();
                        weapon_angle[i] += 22;
                    }
                }
                // end
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 24) weapon_state[i] = 0;
            }

            // CRIMSON GREAT BOW
            else if (weapon_state[i] > 0 && weapon_id[i] == WEAPON_CRIMSON_GREAT_BOW) {
                if (weapon_state[i] == 1) {
                    weapon_angle[i] = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    const start_angle = AddAngles(weapon_angle[i], 180);
                    const velocity = 16;
                    queue_pro_posx, queue_pro_posy = MovePosTowards(unit_x, unit_y, start_angle, 128);
                    queue_pro_maxtime = 16;
                    queue_pro_target_cunit = unit_ptr;
                    queue_pro_velocity = velocity;
                    queue_pro_effect2 = IMAGE_GREEN_FLAME0;
                    queue_pro_effect2_drawfunc = 17;
                    queue_pro_effect2_iscript = ISCRIPT_NORMAL;
                    CreateProjectile();
                    queue_pro_posx, queue_pro_posy = MovePosTowards(unit_x, unit_y, AddAngles(start_angle, 50), 128);
                    queue_pro_maxtime = 16;
                    queue_pro_target_cunit = unit_ptr;
                    queue_pro_velocity = velocity;
                    queue_pro_effect2 = IMAGE_GREEN_FLAME0;
                    queue_pro_effect2_drawfunc = 17;
                    queue_pro_effect2_iscript = ISCRIPT_NORMAL;
                    CreateProjectile();
                    queue_pro_posx, queue_pro_posy = MovePosTowards(unit_x, unit_y, AddAngles(start_angle, -50), 128);
                    queue_pro_maxtime = 16;
                    queue_pro_target_cunit = unit_ptr;
                    queue_pro_velocity = velocity;
                    queue_pro_effect2 = IMAGE_GREEN_FLAME0;
                    queue_pro_effect2_drawfunc = 17;
                    queue_pro_effect2_iscript = ISCRIPT_NORMAL;
                    CreateProjectile();
                }
                if (weapon_state[i] == 20 || weapon_state[i] == 32 || weapon_state[i] == 44) {
                    queue_pro_owner = playerID;
                    queue_pro_posx, queue_pro_posy = unit_x, unit_y;
                    queue_pro_maxtime = 24;
                    queue_pro_angle = weapon_angle[i];
                    queue_pro_velocity = 48;
                    queue_pro_effect0_type = 0;
                    queue_pro_effect0 = 0;
                    queue_pro_effect0_start = 0;
                    queue_pro_effect0_drawfunc = 0;
                    queue_pro_effect0_iscript = 0;
                    queue_pro_effect1_type = 0;
                    queue_pro_effect1 = 0;
                    queue_pro_effect1_start = 0;
                    queue_pro_effect1_drawfunc = 0;
                    queue_pro_effect1_iscript = 0;
                    queue_pro_effect2_type = 0;
                    queue_pro_effect2 = IMAGE_NUKE_DEATH;
                    queue_pro_effect2_start = 0;
                    queue_pro_effect2_drawfunc = 0;
                    queue_pro_effect2_iscript = ISCRIPT_NORMAL;
                    queue_pro_weapon_id = weapon_id[i];
                    queue_pro_collide_enemies = 1;
                    queue_pro_collide_allies = 0;
                    queue_pro_collide_terrain = 0;
                    queue_pro_collide_shape = 0;
                    queue_pro_collide_size = 60;
                    CreateProjectile();
                    const sound_string = GetRandomSoundArrow();
                    PlayWavAtPos(sound_string, unit_x, unit_y, 512);
                }
                // end
                if (weapon_state[i] > 0) weapon_state[i]++;
                if (weapon_state[i] >= 45) weapon_state[i] = 0;
            }
        }
    }
}

function ResetUtilityIndex(i) {
    utility_cunit[i] = 0;
    utility_id[i] = 0;
    utility_state[i] = 0;
    utility_cooldown[i] = 0;
}
// @bm UpdateUtilityState
function UpdateUtilityState(playerID) {
    var check_from = 0;
    var check_to = 0;
    if (playerID < 6) {
        check_from = playerID;
        check_to = playerID + 1;
    } else if (playerID >= 6) {
        check_from = 6;
        check_to = MAX_UTILITY_OBJECTS;
    }
    for (var i = check_from; i < check_to; i++) {
        if (utility_id[i] > 0) {
            var unit_ptr = utility_cunit[i];
            var unit_order_x, unit_order_y = 0, 0;
            var unit_x, unit_y = 0, 0;
            var unit_angle = 0;
            if (playerID < 6) unit_ptr = p_cunit[playerID];
            const unit = CUnit(unit_ptr);
            if (playerID < 6) {
                unit_order_x, unit_order_y = p_orderx[playerID], p_ordery[playerID];
                unit_x, unit_y = p_x[playerID], p_y[playerID];
                unit_angle = p_angle[playerID];
            } else if (playerID >= 6) {
                if (unit.hp == 0) {
                    ResetUtilityIndex(i);
                    continue;
                }
                unit_x = unit.posX;
                unit_y = unit.posY;
                unit_order_x = unit.orderTargetX;
                unit_order_y = unit.orderTargetY;
                unit_angle = SCDirectionToDeg(unit.currentDirection1);
            }
            
            // TRIGGER
            if (utility_cooldown[i] > 0) utility_cooldown[i]--;
            const utility_triggered = CheckForUtilityTrigger(playerID, unit, utility_id[i]);
            if (utility_triggered && utility_cooldown[i] == 0) {
                utility_cooldown[i] = GetUtilityCooldown(utility_id[i]);
                utility_state[i] = 1;
            }

            if (utility_state[i] > 0 && utility_id[i] == UTILITY_DASH) {
                const life_cost = GetUtilityLifeCost(utility_id[i], playerID);
                if (utility_state[i] == 1 && unit.hp > life_cost) DoMagicLifeDrainCost(playerID, unit, life_cost);
                else if (utility_state[i] == 1) utility_state[i] = 0;
                if (playerID < 6 && !IsAlive(playerID)) utility_state[i] = 0;
                if (utility_state[i] == 1) {
                    utility_angle[i] = GetAngle(unit_x, unit_y, unit_order_x, unit_order_y);
                    utility_x[i], utility_y[i] = MovePosTowards(unit_x, unit_y, utility_angle[i], 16);
                    PlayWavAtPos("staredit/wav/dash.ogg", utility_x[i], utility_y[i], 480);
                    const x, y = MovePosTowards(utility_x[i], utility_y[i], utility_angle[i], 64);
                    setloc(L_MAIN, x, y);
                    Order(U_HERO[playerID], playerID, L_ANYWHERE, Move, L_MAIN);
                }
                if (utility_state[i] > 1) {
                    col_posx, col_posy = MovePosTowards(utility_x[i], utility_y[i], utility_angle[i], 24);
                    col_terrain = 1;
                    col_shape_size = 8;
                    CheckCollision(playerID);
                    if (col_results_terrain == 0) {
                        utility_x[i], utility_y[i] = col_posx, col_posy;
                        setloc(L_MAIN, utility_x[i], utility_y[i]);
                        TeleportHeroPos(playerID, utility_x[i], utility_y[i]); // This should be made to account for computer units in the future
                        queue_pro_posx = utility_x[i];
                        queue_pro_posy = utility_y[i];
                        queue_pro_maxtime = 6;
                        queue_pro_angle = (utility_angle[i] - 180) + Random(-10, 10);
                        queue_pro_velocity = 20;
                        queue_pro_angular_velocity = Random(-5, 5);
                        queue_pro_effect1 = IMAGE_FRAG_GRENADE_HIT;
                        queue_pro_effect1_drawfunc = 6;
                        queue_pro_effect1_iscript = ISCRIPT_FAST;
                        queue_pro_effect2 = IMAGE_FRAG_GRENADE_HIT;
                        queue_pro_effect2_start = 3;
                        queue_pro_effect2_drawfunc = 17;
                        queue_pro_effect2_iscript = ISCRIPT_FAST;
                        CreateProjectile();
                    } else {
                        utility_state[i] = 12;
                    }
                    setloc(L_MAIN, utility_x[i], utility_y[i]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_EXPL_BLUE_SMALL, 6, ISCRIPT_FAST);
                    ResetCheckCollision();
                }
                if (utility_state[i] > 0) utility_state[i]++;
                if (utility_state[i] >= 12) {
                    utility_x[i], utility_y[i] = MovePosTowards(utility_x[i], utility_y[i], utility_angle[i], 64);
                    setloc(L_MAIN, utility_x[i], utility_y[i]);
                    Order(U_HERO[playerID], playerID, L_ANYWHERE, Move, L_MAIN);
                    utility_state[i] = 0;
                }
            } else if (utility_id[i] == UTILITY_TORCH && playerID < 6) {
                if (Command(playerID, Exactly, 0, U_TORCH)) {
                    CreateUnit(1, U_TORCH, L_MAIN, playerID);
                }
                CenterLoc(L_MAIN, unit_x, unit_y - 24);
                MoveUnit(1, U_TORCH, playerID, L_ANYWHERE, L_MAIN);
            }
            if (utility_id[i] != UTILITY_TORCH && Command(playerID, AtLeast, 1, U_TORCH)) {
                RemoveUnit(U_TORCH, playerID);
            }
        }
    }
}

function UpdateBeltKeypresses(playerID) {
    const check_from = playerID * PLAYER_MAX_BELT_SLOTS;
    const check_to = check_from + PLAYER_MAX_BELT_SLOTS;
    var iterations = 0;
    for (var i = check_from; i < check_to; i++) {
        if (iterations == 0) keypress_belt[i] = keypress_1[playerID];
        else if (iterations == 1) keypress_belt[i] = keypress_2[playerID];
        else if (iterations == 2) keypress_belt[i] = keypress_3[playerID];
        else if (iterations == 3) keypress_belt[i] = keypress_4[playerID];
        else if (iterations == 4) keypress_belt[i] = keypress_5[playerID];
        else if (iterations == 5) keypress_belt[i] = keypress_6[playerID];
        else if (iterations == 6) keypress_belt[i] = keypress_7[playerID];
        else if (iterations == 7) keypress_belt[i] = keypress_8[playerID];
        else if (iterations == 8) keypress_belt[i] = keypress_9[playerID];
        iterations++;
    }
}

function LevelUp(playerID, unit: CUnit) {
    p_level_current[playerID] += 1;
    p_attributepoints[playerID] += 1;
    p_exp_current[playerID] = 0;
    p_exp_goal[playerID] = 300 + 150 * p_level_current[playerID];
    SetLevelString(playerID);
    screen.printf("LEVEL UP - Level {}", p_level_current[playerID]);
    PlayWAV("staredit/wav/level_up.ogg");
    setloc(L_MAIN, p_x[playerID], p_y[playerID]);
    CreateUnitDeathAtLocation($U("Protoss Observer"), $P8, L_MAIN);
    for (var i = 0; i < 8; i++) {
        queue_pro_posx = p_x[playerID];
        queue_pro_posy = p_y[playerID];
        queue_pro_maxtime = 8;
        queue_pro_angle = (i + 1) * 45;
        queue_pro_velocity = 40;
        queue_pro_angular_velocity = Random(-10, 10);
        queue_pro_effect0 = U_KAKARU;
        queue_pro_effect0_type = 1;
        queue_pro_effect1 = 213;
        queue_pro_effect1_start = queue_pro_maxtime - 1;
        queue_pro_effect2 = 427;
        queue_pro_effect2_start = queue_pro_maxtime;
        CreateProjectile();
    }
}

function FillActiveNearbyUnits(playerID, positionx, positiony) {
    var storage_i = (playerID * ACTIVE_UNITS_MAX) + 1;
    const storage_max = (playerID + 1) * ACTIVE_UNITS_MAX;
    for (var i = storage_i; i < storage_max; i++) active_units[i] = 0;
    const limit_left, limit_right, limit_top, limit_bottom = PosToSquare(positionx, positiony, ACTIVE_UNITS_RECT);
    if (IsAlive(playerID)) active_units[storage_i - 1] = p_cunit[playerID]; // set the first storage index for the player to the player's unit.
    var i = 0;
    foreach(unit : EUDLoopCUnit()) {
        if (unit.playerID == $P7 && unit.hp > 0) {
            if (PosIsWithinRect(unit.posX, unit.posY, limit_left, limit_right, limit_top, limit_bottom)) { // check if unit is within square, if it is add it to the active units array.
                active_units[storage_i] = unit;
                storage_i++;
                if (storage_i > storage_max) break;
            }
        } else if (unit.playerID == $P7 && unit.hp == 0) {
            unit.die();
        }
        i++;
        if (i > 1000) {
            DisplayTextAll("NOTICE: CHECKED MORE THAN 1000 UNITS!");
            break;
        }
    }
}

function ResetNPCIndex(index) {
    npc_x[index] = 0;
    npc_y[index] = 0;
    npc_home_x[index] = 0;
    npc_home_y[index] = 0;
    npc_id[index] = 0;
    npc_cunit[index] = 0;
    npc_state0[index] = 0;
    npc_state1[index] = 0;
    npc_state3[index] = 0;
    npc_order_timer[index] = 0;
}
// @bm UpdateNPCs
function UpdateNPCs() {
    npc_cetus_exists = 0;
    for (var i = 0; i < MAX_NPC_UNITS; i++) {
        if (npc_id[i] > 0) {
            const unit = CUnit(npc_cunit[i]);
            var unit_is_alive = 1;
            if (unit.orderID == 0 || unit.hp == 0) unit_is_alive = 0;
            if (unit_is_alive) npc_x[i], npc_y[i] = unit.posX, unit.posY;
            if (npc_id[i] == NPC_GUARDIAN_ANGEL) {
                var unit_angle = SCDirectionToDeg(unit.currentDirection1);
                // dead
                if (!unit_is_alive) {
                    ResetNPCIndex(i);
                    continue;
                }
                // AI
                if (npc_order_timer[i] == 0) {
                    npc_order_timer[i] = 12;
                    if (GetAreaAtPos(npc_home_x[i], npc_home_y[i]) == AREA_GATE_MOUNTAIN) {
                        const players_on_mountain = PlayersAtArea(AREA_GATE_MOUNTAIN);
                        if (players_on_mountain) {
                            unit.setloc(L_MAIN);
                            foreach(p : EUDLoopPlayer()) {
                                if (players_at_area[p]) {
                                    setloc(L_0X0, p_x[p], p_y[p]);
                                    Order(U_GUARDIAN_ANGEL, $P7, L_MAIN, Patrol, L_0X0);
                                    break;
                                }
                            }
                        }
                        if (!players_on_mountain && npc_x[i] != npc_home_x[i] && npc_y[i] != npc_home_y[i]) {
                            unit.setloc(L_MAIN);
                            setloc(L_0X0, npc_home_x[i], npc_home_y[i]);
                            Order(U_GUARDIAN_ANGEL, $P7, L_MAIN, Move, L_0X0);
                        }
                    }
                }
                if (npc_order_timer[i] > 0) npc_order_timer[i]--;

                // wings
                const angular_velocity = 10;
                if (npc_state3[i] == 0) {
                    npc_state3[i] = 2;
                    queue_pro_posx = unit.posX;
                    queue_pro_posy = unit.posY;
                    queue_pro_maxtime = 6;
                    queue_pro_angle = (unit_angle + 90) + (npc_state1[i] - 100);
                    queue_pro_velocity = 40;
                    if (npc_state0[i] == 1) queue_pro_angular_velocity = -angular_velocity;
                    else if (npc_state0[i] == 2) queue_pro_angular_velocity = angular_velocity;
                    queue_pro_effect0_drawfunc = 17;
                    queue_pro_effect1_drawfunc = 17;
                    queue_pro_effect0 = 468;
                    queue_pro_effect1 = 467;
                    queue_pro_effect1_start = 3;
                    queue_pro_effect2 = 466;
                    queue_pro_effect2_start = queue_pro_maxtime;
                    CreateProjectile();
                    queue_pro_posx = unit.posX;
                    queue_pro_posy = unit.posY;
                    queue_pro_maxtime = 6;
                    queue_pro_angle = (unit_angle - 90) - (npc_state1[i] - 100);
                    queue_pro_velocity = 40;
                    if (npc_state0[i] == 1) queue_pro_angular_velocity = angular_velocity;
                    else if (npc_state0[i] == 2) queue_pro_angular_velocity = -angular_velocity;
                    queue_pro_effect0_drawfunc = 17;
                    queue_pro_effect1_drawfunc = 17;
                    queue_pro_effect0 = 468;
                    queue_pro_effect1 = 467;
                    queue_pro_effect1_start = 3;
                    queue_pro_effect2 = 466;
                    queue_pro_effect2_start = queue_pro_maxtime;
                    CreateProjectile();
                    const wing_speed = 4;
                    if (npc_state0[i] == 0) {
                        npc_state0[i] = 1;
                        npc_state1[i] = 100;
                    }
                    if (npc_state0[i] == 1) npc_state1[i] += wing_speed;
                    else if (npc_state0[i] == 2) npc_state1[i] -= wing_speed;
                    if (npc_state0[i] == 1 && npc_state1[i] >= 150) npc_state0[i] = 2;
                    else if (npc_state0[i] == 2 && npc_state1[i] <= 50) {
                        npc_state0[i] = 1;
                        PlayWavAtPos("staredit/wav/angel0.ogg", npc_x[i], npc_y[i], 512);
                    }
                }
                if (npc_state3[i] > 0) npc_state3[i]--;
            } else if (npc_id[i] == NPC_CETUS) {
                npc_cetus_exists = 1;
                const lair_x, lair_y = 384, 1568;
                if (GetAreaAtPos(npc_x[i], npc_y[i]) != AREA_CETUS_LAIR) { // keep cetus in his lair
                    setloc(L_MAIN, npc_x[i], npc_y[i]);
                    setloc(L_0X0, lair_x, lair_y);
                    MoveUnit(1, U_LOST_KNIGHT, $P7, L_MAIN, L_0X0);
                    CreateImageSpriteAtLocation($P7, L_MAIN, IMAGE_HALLUC_DEATH1, 17, ISCRIPT_FAST);
                    CreateImageSpriteAtLocation($P7, L_0X0, IMAGE_HALLUC_DEATH1, 17, ISCRIPT_FAST);
                    npc_x[i], npc_y[i] = unit.posX, unit.posY;
                }
                // npc_state0 - combat loop
                if (PlayersAtArea(AREA_CETUS_LAIR) && npc_state0[i] == 0) {
                    npc_state0[i] = 1;
                    PlayWavAtPos("staredit/wav/boss_incoming.ogg", npc_x[i], npc_y[i], 960);
                    CenterLoc(L_16X16, lair_x, lair_y);
                    RemoveUnitAt(All, U_ANANSI, L_16X16, $P7);
                    RemoveUnitAt(All, U_CHIMERA, L_16X16, $P7);
                } else if (!PlayersAtArea(AREA_CETUS_LAIR) && npc_state0[i] > 0) {
                    npc_state0[i] = 0;
                    unit.hp = 600 * 256;
                }
                if (npc_state0[i] > 0 && unit_is_alive) {
                    if ((npc_state0[i] <= 120 && npc_state0[i] % 24 == 0) || (npc_state0[i] >= 288 && npc_state0[i] <= 408 && npc_state0[i] % 24 == 0)) {
                        PlayWavAtPos("staredit/wav/boss_charge.ogg", npc_x[i], npc_y[i], 960);
                    }
                    if (npc_state0[i] <= 144 && npc_state0[i] % 2 == 0) { // charge up first summon (0 - 6 seconds)
                        queue_pro_posx, queue_pro_posy = MovePosTowards(npc_x[i], npc_y[i], Random(0, 359), 320);
                        queue_pro_maxtime = 12;
                        queue_pro_velocity = 20;
                        queue_pro_effect2 = IMAGE_PHOTON_BLASTERS;
                        queue_pro_effect2_drawfunc = 17;
                        queue_pro_effect2_iscript = ISCRIPT_FAST;
                        queue_pro_target_cunit = npc_cunit[i];
                        CreateProjectile();
                    } else if (npc_state0[i] == 145) { // do first summon (on 6 seconds)
                        DrawCircle(lair_x, lair_y, 448, 12, IMAGE_ZERG_AIR_DEATH_LARGE, 0, ISCRIPT_FAST);
                        setloc(L_MAIN, lair_x, lair_y);
                        CenterLoc(L_16X16, lair_x, lair_y);
                        CreateUnitCircle(U_ANANSI, $P7, L_MAIN, 448, 10);
                        Order(U_ANANSI, $P7, L_16X16, Patrol, L_16X16);
                        PlayWavAtPos("sound\Bullet\ZQuHit02.wav", npc_x[i], npc_y[i], 960);
                    } else if (npc_state0[i] >= 288 && npc_state0[i] <= 432 && npc_state0[i] % 2 == 0) { // charge up second summon (12 - 18 seconds)
                        queue_pro_posx, queue_pro_posy = MovePosTowards(npc_x[i], npc_y[i], Random(0, 359), 320);
                        queue_pro_maxtime = 12;
                        queue_pro_velocity = 20;
                        queue_pro_effect2 = IMAGE_PHOTON_BLASTERS;
                        queue_pro_effect2_drawfunc = 17;
                        queue_pro_effect2_iscript = ISCRIPT_FAST;
                        queue_pro_target_cunit = npc_cunit[i];
                        CreateProjectile();
                    } else if (npc_state0[i] == 433) { // do second summon (on 18 seconds)
                        DrawCircle(lair_x, lair_y, 448, 12, IMAGE_ZERG_AIR_DEATH_LARGE, 0, ISCRIPT_FAST);
                        setloc(L_MAIN, lair_x, lair_y);
                        CenterLoc(L_16X16, lair_x, lair_y);
                        CreateUnitCircle(U_CHIMERA, $P7, L_MAIN, 448, 10);
                        Order(U_CHIMERA, $P7, L_16X16, Patrol, L_16X16);
                        PlayWavAtPos("sound\Bullet\ZQuHit02.wav", npc_x[i], npc_y[i], 960);
                    } else if (npc_state0[i] >= 576 && npc_state0[i] % 12 == 0) { // consume chimeras in the lair after 24 seconds
                        CenterLoc(L_16X16, lair_x, lair_y);
                        if (Bring($P7, AtLeast, 1, U_CHIMERA, L_16X16)) {
                            HealUnit(npc_cunit[i], 10 * 256, 600 * 256);
                            PlayWavAtPos("sound\Bullet\ZHyFir00.wav", lair_x, lair_y, 960);
                            MoveLocation(L_MAIN, U_CHIMERA, $P7, L_16X16);
                            KillUnitAt(1, U_CHIMERA, L_MAIN, $P7);
                            queue_pro_posx, queue_pro_posy = GetLocationPoint(L_MAIN);
                            queue_pro_maxtime = 16;
                            queue_pro_velocity = 12;
                            queue_pro_effect1 = IMAGE_SPORES_OVERLAY;
                            queue_pro_effect1_iscript = ISCRIPT_FAST;
                            queue_pro_effect1_drawfunc = 6;
                            queue_pro_effect2_start = 7;
                            queue_pro_effect2 = IMAGE_SPORES_OVERLAY;
                            queue_pro_effect2_iscript = ISCRIPT_FAST;
                            queue_pro_target_cunit = npc_cunit[i];
                            CreateProjectile();
                        }
                    }
                    npc_state0[i]++;
                    if (npc_state0[i] >= 720) npc_state0[i] = 1;
                }
                // death
                if (!unit_is_alive && npc_state1[i] == 0) npc_state1[i] = 1;
                if (npc_state1[i] > 0) {
                    if (npc_state1[i] == 1) {
                        for (var j = 0; j < 8; j++) {
                            queue_pro_posx, queue_pro_posy = npc_x[i], npc_y[i];
                            queue_pro_maxtime = 8;
                            queue_pro_angle = (j + 1) * 45;
                            queue_pro_velocity = 40;
                            queue_pro_angular_velocity = Random(-10, 10);
                            queue_pro_effect2 = 103;
                            queue_pro_effect2_type = 1;
                            CreateProjectile();
                        }
                        setloc(L_MAIN, npc_x[i], npc_y[i]);
                        CreateUnitDeathAtLocation(U_KAKARU, $P8, L_MAIN);
                    } else if (npc_state1[i] == 24) {
                        PlayWavAtPos("staredit/wav/boss_death0.ogg", npc_x[i], npc_y[i], 960);
                    } else if (npc_state1[i] > 48 && npc_state1[i] % 4 == 0) {
                        queue_pro_posx, queue_pro_posy = npc_x[i], npc_y[i];
                        queue_pro_maxtime = 12;
                        queue_pro_angle = Random(0, 359);
                        queue_pro_velocity = 25;
                        queue_pro_angular_velocity = Random(-10, 10);
                        queue_pro_effect2 = IMAGE_ZERG_AIR_DEATH_SMALL;
                        queue_pro_effect2_iscript = ISCRIPT_NORMAL;
                        if (npc_state1[i] % 12 == 0) {
                            queue_pro_effect2_drawfunc = 17;
                        }
                        CreateProjectile();
                        PlayWavAtPos("sound\Zerg\Guardian\ZGuDth00.WAV", npc_x[i], npc_y[i], 960);
                        setloc(L_MAIN, npc_x[i], npc_y[i]);
                        CreateImageSpriteAtLocation($P7, L_MAIN, IMAGE_ZERG_AIR_DEATH_LARGE, 0, ISCRIPT_NORMAL);
                    }
                    // if (npc_state1[i] == 72) PlayWavAtPos("staredit/wav/boss_destroyed.ogg", npc_x[i], npc_y[i], 960);
                    npc_state1[i]++;
                    if (npc_state1[i] >= 216) {
                        for (var j = 0; j < 8; j++) {
                            queue_pro_posx, queue_pro_posy = npc_x[i], npc_y[i];
                            queue_pro_maxtime = 12;
                            queue_pro_angle = (j + 1) * 45;
                            queue_pro_velocity = 25;
                            queue_pro_angular_velocity = Random(-10, 10);
                            queue_pro_effect2 = IMAGE_ZERG_AIR_DEATH_SMALL;
                            queue_pro_effect2_iscript = ISCRIPT_NORMAL;
                            queue_pro_effect2_drawfunc = 17;
                            CreateProjectile();
                        }
                        PlayWavAtPos("staredit/wav/boss_destroyed.ogg", npc_x[i], npc_y[i], 960);
                        setloc(L_MAIN, npc_x[i], npc_y[i]);
                        CreateItemUnit(U_WEAPON, WEAPON_CRIMSON_LONG_SWORD, L_MAIN, 1, 1);
                        ResetNPCIndex(i);
                    }
                }
                // show hp to players
                if (unit_is_alive) {
                    const old_cp = getcurpl();
                    foreach(player : EUDLoopPlayer()) {
                        setcurpl(player);
                        if (GetAreaAtPos(p_x[player], p_y[player]) == AREA_CETUS_LAIR) {
                            const life_percent = GetPercentage(unit.hp / 256, 600);
                            screen.printfAt(0, "\x13\x08LOST KNIGHT CETUS \x02- \x07{}%", life_percent);
                        }
                    }
                    setcurpl(old_cp);
                }
            }
        }
    }
}

// @bm onPluginStart
function onPluginStart() {
    randomize();
    SpawnInitialItemUnits();
    StoreHarvestPositions();
    StoreSpawnPositions();
    SetupSystemUnits();
    SetupWorldInteractions();
    SetupBeltDefaults();
    EUDPlayerLoop()();
        const playerID = getcurpl();
        if (playerID < 6) {
            for (var i = 0; i < 6; i++) SetAllianceStatus(i, Ally);
            SetAllianceStatus($P7, Enemy);
            SetAllianceStatus($P8, Ally);
            SetHeroDefaults(playerID);
            if (debug_enabled) {
                p_attributepoints[playerID] = 20;
                EquipItem(ARMOR_SHATTERED_KNIGHTS, U_ARMOR, playerID);
                EquipItem(WEAPON_CRIMSON_GREAT_BOW, U_WEAPON, playerID);
                EquipItem(UTILITY_TORCH, U_UTILITY, playerID);
                SetMaxHP(playerID, 140 * 256);
                GetVision($P7);
                // EquipBeltSlot(CONSUMABLE_BANDAGE, playerID, 0, 3);
                // EquipBeltSlot(CONSUMABLE_BANDAGE, playerID, 1, 3);
                // EquipBeltSlot(CONSUMABLE_BANDAGE, playerID, 2, 3);
                // EquipBeltSlot(CONSUMABLE_BANDAGE, playerID, 3, 3);
                // EquipBeltSlot(CONSUMABLE_BANDAGE, playerID, 4, 3);
                // EquipBeltSlot(CONSUMABLE_BANDAGE, playerID, 5, 3);
            }
            PlaySong(0);
        }
    EUDEndPlayerLoop();
}
// @bm afterTriggerExec
function afterTriggerExec() {
    UpdateTime();
    UpdateProjectiles();
    UpdateProjectileCollisions();
    UpdateSigils();

    // RESET STUFF WHEN NIGHT TURNS TO DAY
    if (time_state_changed && time_state == 0) {
        RemoveUnit(U_CHIMERA, $P7);
        RemoveUnit(U_HILL_SPINT, $P7);
        RemoveUnit(U_ANANSI, $P7);
        RemoveUnit(U_GUARDIAN_ANGEL, $P7);
        RemoveUnit(U_TWISTED_KNIGHT, $P7);
        var reset_count = 0;
        for (var i = 0; i < 256; i++) {
            if (chunk_spawns[i] > 0) {
                chunk_spawns[i] = 0;
                reset_count += 1;
            }
        }
        // screen.printf("reset spawns for {} chunks", reset_count);
        // reset harvestables
        for (var i = 0; i < MAX_HARVEST_POSITIONS; i++) {
            if (harvest_type[i] > 0) harvest_state[i] = GetSumOfActivePlayerBits();
        }
    }

    EUDPlayerLoop()();
        const playerID = getcurpl();
        // HUMAN PLAYERS
        if (playerID < 6) {
            UpdateBeltKeypresses(playerID);
            const unit = CUnit(p_cunit[playerID]);
            var unit_is_moving = 0;
            p_just_attacked[playerID] = 0;
            p_order_input[playerID] = 0;
            if (m_disable_delay[playerID] > 0) m_disable_delay[playerID]--;
            var unit_is_indoors = 0;
            var unit_took_health_damage = 0;
            if (p_interaction_prompt_delay[playerID] > 0) p_interaction_prompt_delay[playerID]--;
            if (IsAlive(playerID)) {
                p_x[playerID], p_y[playerID] = unit.posX, unit.posY;
                p_angle[playerID] = SCDirectionToDeg(unit.currentDirection1);
                p_orderx[playerID], p_ordery[playerID] = unit.orderTargetX, unit.orderTargetY;
                if (active_units_update == 0) FillActiveNearbyUnits(playerID, p_x[playerID], p_y[playerID]);
                if (unit.orderID == ORDER_HOLD || unit.orderID == ORDER_PATROL) {
                    p_order_input[playerID] = unit.orderID;
                    unit.orderID = 3;
                }
                if (p_x[playerID] == p_x_old[playerID] && p_y[playerID] == p_y_old[playerID]) {
                    unit_is_moving = 0;
                } else {
                    // confine movement for lairs
                    if (p_entered_lair[playerID] > 0) {
                        if (
                            GetAreaAtPos(p_x[playerID], p_y[playerID]) != p_entered_lair[playerID] && 
                            GetAreaAtPos(p_x_old[playerID], p_y_old[playerID]) == p_entered_lair[playerID]
                        ) {
                            setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                            CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_HALLUC_DEATH1, 17, ISCRIPT_NORMAL);
                            TeleportHeroPos(playerID, p_x_old[playerID], p_y_old[playerID]);
                            p_x[playerID], p_y[playerID] = p_x_old[playerID], p_y_old[playerID];
                        }
                    }
                    // update coordinates
                    p_x_old[playerID] = p_x[playerID];
                    p_y_old[playerID] = p_y[playerID];
                    unit_is_moving = 1;
                }
                if (!unit_is_moving && unit.currentSpeed1 > 0) {
                    unit.currentSpeed1 = 0; // Unit stuck because of flingy movement fix.
                    unit.currentSpeed2 = 0;
                }
                unit.orderTimer = 0;
                unit.orderQueueTimer = 0;
                if (GetAreaAtPos(p_x[playerID], p_y[playerID]) == AREA_CETUS_LAIR) {
                    if (p_entered_lair[playerID] == 0 && npc_cetus_exists) p_entered_lair[playerID] = AREA_CETUS_LAIR;
                    else if (p_entered_lair[playerID] > 0 && !npc_cetus_exists) p_entered_lair[playerID] = 0;
                }
            }
            if (unit_is_moving && IsAlive(playerID)) {
                const x, y = GetChunkAtPos(p_x[playerID], p_y[playerID]);
                if (p_chunk_x_old[playerID] != x || p_chunk_y_old[playerID] != y) {
                    p_chunk_x_old[playerID] = x;
                    p_chunk_y_old[playerID] = y;
                    JustEnteredChunk(x, y);
                }
                p_indoors[playerID] = IsPosIndoors(p_x[playerID], p_y[playerID]);
                // check for nearby sigils
                var sigil = MAX_SIGIL_SPAWNS;
                for (var i = 0; i < MAX_SIGIL_SPAWNS; i++) {
                    if (sigil_x[i] > 0) {
                        const dist = GetDistance(p_x[playerID], p_y[playerID], sigil_x[i], sigil_y[i]);
                        if (dist <= SIGIL_DIAMETER / 2) {
                            sigil = i;
                            break;
                        }
                    }
                }
                if (sigil < MAX_SIGIL_SPAWNS && p_on_sigil[playerID] == 0) {
                    p_on_sigil[playerID] = 1;
                    p_current_sigil[playerID] = sigil;
                    DrawCircle(sigil_x[sigil], sigil_y[sigil], SIGIL_DIAMETER, 24, 443, 0, ISCRIPT_NORMAL);
                    DisplayText("\x13\x04Press \x03-<F>- \x04to Interact.");
                } else if (sigil >= MAX_SIGIL_SPAWNS && p_on_sigil[playerID] > 0) {
                    p_on_sigil[playerID] = 0;
                }
                // check for nearby world interactions
                var world_interaction_index = MAX_WORLD_INTERACTIONS;
                for (var i = 0; i < MAX_WORLD_INTERACTIONS; i++) {
                    if (world_interaction_x[i] > 0) {
                        const l, r, t, b = PosToSquare(world_interaction_x[i], world_interaction_y[i], world_interaction_size[i]);
                        if (PosIsWithinRect(p_x[playerID], p_y[playerID], l, r, t, b)) {
                            world_interaction_index = i;
                            break;
                        }
                    }
                }
                if (world_interaction_index < MAX_WORLD_INTERACTIONS && p_on_world_interaction[playerID] == 0) {
                    p_on_world_interaction[playerID] = world_interaction_index + 1;
                    setloc(L_MAIN, world_interaction_x[p_on_world_interaction[playerID] - 1], world_interaction_y[p_on_world_interaction[playerID] - 1]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_SCARAB_MISSILE, 17, ISCRIPT_FAST);
                    if (p_interaction_prompt_delay[playerID] == 0) {
                        p_interaction_prompt_delay[playerID] = 72;
                        const text = GetStringWorldInteractionPrompt(p_on_world_interaction[playerID] - 1);
                        screen.printf("{:s}", text);
                    }
                } else if (world_interaction_index >= MAX_SIGIL_SPAWNS && p_on_world_interaction[playerID] > 0) {
                    p_on_world_interaction[playerID] = 0;
                }
                // check for nearby harvestables
                const l, r, t, b = PosToSquare(p_x[playerID], p_y[playerID], 96);
                for (var i = 0; i < MAX_HARVEST_POSITIONS; i++) {
                    if (PosIsWithinRect(harvest_x[i], harvest_y[i], l, r, t, b) && (harvest_state[i] & (1 << playerID))) {
                        harvest_state[i] &= ~(1 << playerID);
                        RedeemMaterial(playerID, harvest_type[i]);
                        RedeemMaterial(playerID, MATERIAL_PLANT_FIBER);
                        setloc(L_MAIN, harvest_x[i], harvest_y[i]);
                        CreateUnitDeathAtLocation(89, $P7, L_MAIN);
                    }
                }
                // check for nearby item units
                if (p_nearby_item_unit[playerID] == 0) {
                    CenterLoc(L_3X3, p_x[playerID], p_y[playerID]);
                    if (
                        Bring($P8, AtLeast, 1, U_WEAPON, L_3X3) ||
                        Bring($P8, AtLeast, 1, U_ARMOR, L_3X3) ||
                        Bring($P8, AtLeast, 1, U_LIFEPICKUP, L_3X3) ||
                        Bring($P8, AtLeast, 1, U_UTILITY, L_3X3) ||
                        Bring($P8, AtLeast, 1, U_CONSUMABLE, L_3X3)
                    ) {
                        p_nearby_item_unit[playerID] = 1;
                        DisplayText("\x13\x03<Attack> \x04to Interact.");
                    }
                } else if (p_nearby_item_unit[playerID] > 0) {
                    CenterLoc(L_3X3, p_x[playerID], p_y[playerID]);
                    if (
                        Bring($P8, Exactly, 0, U_WEAPON, L_3X3) &&
                        Bring($P8, Exactly, 0, U_ARMOR, L_3X3) &&
                        Bring($P8, Exactly, 0, U_LIFEPICKUP, L_3X3) &&
                        Bring($P8, Exactly, 0, U_UTILITY, L_3X3) &&
                        Bring($P8, Exactly, 0, U_CONSUMABLE, L_3X3)
                    ) {
                        p_nearby_item_unit[playerID] = 0;
                    }
                }
            }
            UpdateBrightness(playerID);
            UpdateSightRange(playerID);

            // SIGIL INTERACTION
            if (p_on_sigil[playerID] && IsAlive(playerID)) {
                if (m_main[playerID] == 0 && keypress_f[playerID] > 0) {
                    m_main[playerID] = MENU_MAIN_SIGIL;
                } else if (m_main[playerID] == MENU_MAIN_SIGIL) {
                    UpdateSigilMenu(playerID);
                }
                // set to home if this is the players first sigil
                const x, y = GetSpawnPosition(playerID);
                if (p_homepos_x[playerID] == x && p_homepos_y[playerID] == y) {
                    p_homepos_x[playerID] = sigil_x[p_current_sigil[playerID]];
                    p_homepos_y[playerID] = sigil_y[p_current_sigil[playerID]];
                }

            } else if (p_on_sigil[playerID] == 0 && m_main[playerID] == MENU_MAIN_SIGIL) {
                m_main[playerID] = 0;
                ClearTextLines(0, 9);
            }

            // @bm WORLD INTERACTIONS
            if (p_on_world_interaction[playerID] && IsAlive(playerID)) {
                const index = p_on_world_interaction[playerID] - 1;
                if (index <= 2) { // Field Pillars
                    if (m_main[playerID] == 0 && keypress_f[playerID] > 0) {
                        m_main[playerID] = MENU_MAIN_FIELD_PILLAR;
                    } else if (m_main[playerID] == MENU_MAIN_FIELD_PILLAR) {
                        if (keypress_1[playerID]) {
                            if (field_puzzle_state[index] >= 4) field_puzzle_state[index] = 1;
                            else field_puzzle_state[index]++;
                            world_interaction_visual_timer = 1;
                        }
                        if (field_puzzle_state_solution[index] == 1) {
                            DisplayTextAt(0, "\x09\x09\x09\x02The inscription reads: \x04\"Where the frost-kissed feathers of the snow owl catch the first light,");
                            DisplayTextAt(1, "\x09\x09\x09\x04darkness stirs in silent anticipation.\"");
                        } else if (field_puzzle_state_solution[index] == 2) {
                            DisplayTextAt(0, "\x09\x09\x09\x02The inscription reads: \x04\"With the rising sun, the crane takes flight,");
                            DisplayTextAt(1, "\x09\x09\x09\x04casting shadows that guide the unborn to awaken in the warmth of the dawn.\"");
                        } else if (field_puzzle_state_solution[index] == 3) {
                            DisplayTextAt(0, "\x09\x09\x09\x02The inscription reads: \x04\"In the fiery embrace of the midday sun, the phoenix soars,");
                            DisplayTextAt(1, "\x09\x09\x09\x04signaling the faithful to embrace the radiant energy of the sky.\"");
                        } else if (field_puzzle_state_solution[index] == 4) {
                            DisplayTextAt(0, "\x09\x09\x09\x02The inscription reads: \x04\"As the day bids farewell and the heron glides towards the horizon,");
                            DisplayTextAt(1, "\x09\x09\x09\x04a secret is whispered by the western winds.\"");
                        }
                        DisplayTextAt(2, "\x0BNull");
                        DisplayTextAt(3, "\x09\x09\x09\x03Press -<1>- to Spin the attached Stone Handle.");
                    }
                } else if (index == 3 && keypress_f[playerID] > 0) { // Juyet's field note
                    const line0 = Db("\x09\x09\x09\x02The note reads: \x04Hey, if you're reading this, I've been captured by some idiotic lost soul.\n");
                    const line1 = Db("\x09\x09\x09\x04I'm likely trapped in the cave to the south. I can help you with some things if I'm free...\n");
                    const line2 = Db("\x09\x09\x09\x04Up to you though, no rush... I guess I'll find out what you think soon enough.\n");
                    const line3 = Db("\x09\x09\x09\x02Signed: \x1BJuyet The Restless Spirit\n");
                    screen.printfAt(0, "{:s}{:s}{:s}{:s}", line0, line1, line2, line3);
                } else if (index == 4) { // Crafting table
                    if (m_main[playerID] == 0 && keypress_f[playerID] > 0) {
                        m_main[playerID] = MENU_MAIN_CRAFTING;
                    }
                }
            } else if (p_on_world_interaction[playerID] == 0 && m_main[playerID] == MENU_MAIN_FIELD_PILLAR) {
                m_main[playerID] = 0;
                ClearTextLines(0, 3);
            } else if (p_on_world_interaction[playerID] == 0 && m_main[playerID] == MENU_MAIN_CRAFTING) {
                m_main[playerID] = 0;
                ClearTextLines(0, 3);
            }
            // CRAFTING MENU
            if (m_main[playerID] == MENU_MAIN_CRAFTING) {
                UpdateCraftingMenu(playerID);
            }

            // HEALTH
            if (IsAlive(playerID)) {
                const regen_amount = GetHealthRegen(playerID);
                HealPlayer(playerID, unit, regen_amount);
                if (unit.hp > p_life[playerID]) {
                    if (unit.hp > p_life_max[playerID]) unit.hp = p_life_max[playerID];
                    const health_gained = unit.hp - p_life[playerID];
                    p_life[playerID] = unit.hp;
                    // const gained_whole, gained_frac = GetWholeAndFraction((health_gained * 10000) / 256);
                    // screen.printf("{}.{} health gained", gained_whole, gained_frac);
                }
                if (unit.hp < p_life[playerID]) {
                    const health_lost = p_life[playerID] - unit.hp;
                    unit_took_health_damage = health_lost;
                    const amount_recovered = GetHealthToughnessDeduction(playerID, health_lost);
                    HealPlayer(playerID, unit, amount_recovered); // toughness from dexterity
                    p_life[playerID] = unit.hp;
                    // const recovered_whole, recovered_frac = GetWholeAndFraction((amount_recovered * 10000) / 256);
                    // screen.printf("{} health LOST! Recovered {}.{} from toughness.", health_lost / 256, recovered_whole, recovered_frac);
                }
            }

            // SHIELDS/ARMOR
            if (IsAlive(playerID)) {
                CenterLocHero(L_16X16, playerID);
                if (unit.shield != p_shield_max[playerID] && !EnemiesAtLoc(L_16X16)) {
                    HealShieldPlayer(playerID, unit, 256);
                    p_shield[playerID] = unit.shield;
                }
                CenterLocHero(L_3X3, playerID);
                if (EnemiesAtLoc(L_3X3) && p_shield_recover[playerID] == 0) p_shield_recover[playerID] = 1;
                else if (!EnemiesAtLoc(L_3X3) && p_shield_recover[playerID] > 0) {
                    p_shield_recover[playerID] = 0;
                    p_shield[playerID] = p_shield_max[playerID];
                    if (unit.shield < p_shield_max[playerID]) {
                        HealShieldPlayer(playerID, unit, p_shield_max[playerID]);
                        CreateImageSpriteAtLocation($P8, L_3X3, 377, 0, ISCRIPT_NORMAL);
                        PlayWAV("staredit/wav/dodge.ogg");
                    }
                }
                if (unit.shield == p_shield_max[playerID] && p_shield_broken[playerID] > 0) p_shield_broken[playerID] = 0;
                else if (p_shield_broken[playerID] > 0) unit.shield = 0;
                if (unit.shield > p_shield[playerID]) {
                    if (unit.shield > p_shield_max[playerID]) unit.shield = p_shield_max[playerID];
                    const armor_gained = unit.shield - p_shield[playerID];
                    p_shield[playerID] = unit.shield;
                    // const gained_whole, gained_frac = GetWholeAndFraction((armor_gained * 10000) / 256);
                    // screen.printf("{}.{} armor gained", gained_whole, gained_frac);
                }
                if (unit.shield < p_shield[playerID]) {
                    const armor_lost = p_shield[playerID] - unit.shield;
                    const amount_recovered = GetArmorToughnessDeduction(playerID, armor_lost);
                    HealShieldPlayer(playerID, unit, amount_recovered); // toughness from resilience
                    // const recovered_whole, recovered_frac = GetWholeAndFraction((amount_recovered * 10000) / 256);
                    // screen.printf("\x06{}! \x02+{}.{}", armor_lost / 256, recovered_whole, recovered_frac);
                    // screen.printf("\x06{}!", (armor_lost - amount_recovered) / 256);
                    if (unit_took_health_damage && p_shield[playerID] >= 256) {
                        p_shield_broken[playerID] = 1;
                        // DisplayText("\x13\x06-! ARMOR BROKEN !-");
                        PlayWAV("staredit/wav/shields_broke.ogg");
                        setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                        CreateImageSpriteAtLocation($P8, L_MAIN, 107, 16, ISCRIPT_NORMAL);
                    }
                    p_shield[playerID] = unit.shield;
                }
            }

            // @bm UNIT ATTACK
            if (IsAlive(playerID)) {
                if (unit.groundWeaponCooldown == 26) {
                    p_just_attacked[playerID] = 1;
                    unit.groundWeaponCooldown -= GetAttackSpeed(playerID);
                    const target = unit.orderTargetUnit;
                    const target_loot_status = target.shield;
                    var target_is_valid = 1;
                    // LOOTING
                    if (IsUnitItem(target.unitID)) {
                        unit.orderID = 3;
                        CenterLocHero(L_MAIN, playerID);
                        Order(U_HERO[playerID], playerID, L_ANYWHERE, Move, L_MAIN);
                        p_just_attacked[playerID] = 0;
                        CenterLocHero(L_16X16, playerID);
                        ModifyUnitHitPoints(All, target.unitID, $P8, L_16X16, 100);
                        target_is_valid = 0;
                        if (UnitItemHasBeenLooted(playerID, target.shield)) {
                            DisplayText("\x13\x04You've already looted this.");
                        } else {
                            p_current_item_unit[playerID] = target;
                            PlayWAV("staredit/wav/check_item.ogg");
                        }
                        if (target.unitID == U_LIFEPICKUP && !UnitItemHasBeenLooted(playerID, target_loot_status)) {
                            p_current_item_unit[playerID] = 0;
                            target.shield = ModifyItemLootedStatus(playerID, target_loot_status);
                            SetMaxHP(playerID, p_life_max[playerID] + PLAYER_LIFE_PICKUP_INCREASE);
                        }
                        if (target.shield == 0) { // remove the unit if the loot status returns 0
                            setloc(L_MAIN, target.posX, target.posY);
                            RemoveUnitAt(1, target.unitID, L_MAIN, $P8);
                        }
                    }
                    if (target_is_valid) {
                        DamageUnit(playerID, target, p_damage[playerID], ACTIVE_UNITS_MAX + 1);
                        if (utility_id[playerID] == UTILITY_TORCH && Random(0, 1) == 0) { // torch damage
                            col_posx, col_posy = p_x[playerID], p_y[playerID];
                            col_enemies = 1;
                            col_shape = 1;
                            col_shape_size = 128;
                            col_max_results = 4;
                            const result = CheckCollision(playerID);
                            if (result) {
                                for (var i = 0; i < col_max_results; i++) {
                                    if (col_results_unit[i] > 0) {
                                        const target = CUnit(col_results_unit[i]);
                                        setloc(L_MAIN, target.posX, target.posY);
                                        CreateImageSpriteAtLocation($P7, L_MAIN, IMAGE_ORANGE_FLAME_SMALL0, 0, ISCRIPT_NORMAL);
                                        DamageUnit(playerID, target, 8, ACTIVE_UNITS_MAX + 1);
                                    }
                                }
                            }
                            ResetCheckCollision();
                        }
                    }
                }
            }

            // LOOT MENU
            if (p_current_item_unit[playerID] > 0) {
                const item_unit = CUnit(p_current_item_unit[playerID]);
                const item_id = item_unit.energy;
                const item_looted_status = item_unit.shield;
                const item_amount = item_unit.unknown0x86;
                const item_unit_type = item_unit.unitID;
                const item_x, item_y = item_unit.posX, item_unit.posY;
                if (GetDistance(p_x[playerID], p_y[playerID], item_x, item_y) > CLOSE_LOOT_MENU_DISTANCE) {
                    ClearTextLines(0, 4);
                    p_current_item_unit[playerID] = 0;
                    m_disable_delay[playerID] = 12;
                } else {
                    const item_name = GetStringItemName(item_id, item_unit_type);
                    const item_description = GetStringItemDescription(item_id, item_unit_type);
                    var equipped_id = 0; // whatever is currently equipped in the target slot
                    if (item_unit_type == U_WEAPON) equipped_id = weapon_id[playerID];
                    else if (item_unit_type == U_ARMOR) equipped_id = p_armor[playerID];
                    else if (item_unit_type == U_UTILITY) equipped_id = utility_id[playerID];
                    const equipped_name = GetStringItemName(equipped_id, item_unit_type);
                    ResetAuxiliaryArray();
                    aux_array[0], aux_array[1], aux_array[2] = GetItemInteractionIDs(item_id, item_unit_type);
                    if (item_amount <= 1) screen.printfAt(0, "\x09\x09\x09\x09\x09\x09\x04--+ \x1F{:s}", item_name);
                    else if (item_amount > 1) screen.printfAt(0, "\x09\x09\x09\x09\x09\x09\x04--+ \x1F{:s} \x04x{}", item_name, item_amount);
                    screen.printfAt(1, "\x09\x09\x09\x09\x09\x09\x09\x09\x02{:s}", item_description);
                    var action_equipped = 0;
                    var action_equipped_available_belt = 0;
                    var action_equipped_specific_belt = 0;
                    var action_dragged = 0;
                    for (var i = 0; i < 3; i++) {
                        if (aux_array[i] == 0) { // no interaction
                            screen.printfAt(2 + i, "\x09\x0BNothing");
                        } else if (aux_array[i] == 1) { // equip
                            if (keypress_1[playerID]) action_equipped = 1;
                            if (equipped_id > 0) screen.printfAt(2 + i, "\x09\x09\x09\x09\x09\x09\x09\x09\x03-<1>- \x04to Equip and swap with: \x1F{:s}", equipped_name);
                            else screen.printfAt(2 + i, "\x09\x09\x09\x09\x09\x09\x09\x09\x03-<1>- \x04to Equip.");
                        } else if (aux_array[i] == 2) { // equip to available belt
                            if (keypress_f[playerID]) action_equipped_available_belt = 1;
                            screen.printfAt(2 + i, "\x09\x09\x09\x09\x09\x09\x09\x09\x03-<F>- \x04to Equip to first Available Slot.");
                        } else if (aux_array[i] == 3) { // equip to specific belt slot
                            const input = GetInputBeltKeypress(playerID);
                            if (input > 0) action_equipped_specific_belt = input;
                            screen.printfAt(2 + i, "\x09\x09\x09\x09\x09\x09\x09\x09\x03-<1 - 9>- \x04to Equip to Specific Slot.");
                        } else if (aux_array[i] == 4) { // drag
                            if (keypress_g[playerID]) action_dragged = 1;
                            screen.printfAt(2 + i, "\x09\x09\x09\x09\x09\x09\x09\x09\x03-<G>- \x04to Drag.");
                        }
                    }
                    if (action_equipped || action_equipped_available_belt || action_equipped_specific_belt) {
                        item_unit.shield = ModifyItemLootedStatus(playerID, item_looted_status);
                        if (item_unit.shield == 0) { // remove the unit if the loot status returns 0
                            setloc(L_MAIN, item_x, item_y);
                            RemoveUnitAt(1, item_unit_type, L_MAIN, $P8);
                        }
                        m_disable_delay[playerID] = 12;
                    }
                    if (action_equipped) {
                        if (equipped_id > 0) {
                            setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                            CreateItemUnit(item_unit_type, equipped_id, L_MAIN, 0, 1);
                            screen.printf("\x13\x06Dropped \x1F{:s}", equipped_name);
                        }
                        EquipItem(item_id, item_unit_type, playerID);
                        p_current_item_unit[playerID] = 0;
                        ClearTextLines(0, 4);
                        screen.printf("\x13\x04Equipped \x1F{:s}", item_name);
                        PlayWAV("staredit/wav/equip_weapon.ogg");
                    } else if (action_equipped_available_belt || action_equipped_specific_belt > 0) {
                        var target_slot = action_equipped_specific_belt - 1;
                        if (
                            (BeltIsFull(playerID) && item_amount > p_belt_amount_max[playerID]) || 
                            (action_equipped_specific_belt > 0 && GetBeltSlotAmount(playerID, target_slot) >= p_belt_amount_max[playerID] && item_amount > p_belt_amount_max[playerID])
                        ) {
                            // special case for if the incoming amount is greater than the belt max and the belt is full. The system has to create 2 dropped items.
                            const target_slot_id = GetBeltSlotItemID(playerID, target_slot);
                            const target_slot_amount = GetBeltSlotAmount(playerID, target_slot);
                            setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                            CreateItemUnit(item_unit_type, target_slot_id, L_MAIN, target_slot, target_slot_amount);
                            screen.printf("\x13\x06Dropped \x1F{:s} \x04x{}", GetStringItemName(target_slot_id, item_unit_type), target_slot_amount);
                        }
                        var current_slot_number, current_item_id, current_amount, amount_equipped = 0, 0, 0, 0;
                        if (action_equipped_specific_belt > 0) current_slot_number, current_item_id, current_amount, amount_equipped = EquipBeltSlot(item_id, playerID, action_equipped_specific_belt - 1, item_amount);
                        else current_slot_number, current_item_id, current_amount, amount_equipped = EquipBeltAvailable(item_id, playerID, item_amount);
                        PlayWAV("staredit/wav/equip_weapon.ogg");
                        if (current_item_id > 0 && current_amount > 0) {
                            setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                            CreateItemUnit(item_unit_type, current_item_id, L_MAIN, 0, current_amount);
                            screen.printf("\x13\x06Dropped \x1F{:s} \x04x{}", GetStringItemName(current_item_id, item_unit_type), current_amount);
                        }
                        p_current_item_unit[playerID] = 0;
                        ClearTextLines(0, 4);
                        screen.printf("\x13\x04Equipped \x1F{:s} \x04x{} to \x07BELT SLOT {}", item_name, amount_equipped, current_slot_number);
                    }
                }
            }

            // CONSUMABLES
            if (IsAlive(playerID) && !MenuIsOpen(playerID)) {
                const check_from = playerID * PLAYER_MAX_BELT_SLOTS;
                const check_to = check_from + PLAYER_MAX_BELT_SLOTS;
                for (var i = check_from; i < check_to; i++) {
                    if (keypress_belt[i] && p_belt_equipped[i] > 0) {
                        var was_used = 0;
                        if (p_belt_equipped[i] == CONSUMABLE_BANDAGE && p_cons_bandage_state[playerID] == 0 && p_belt_amount[i] > 0) {
                            p_cons_bandage_state[playerID] = 1;
                            was_used = 1;
                        } else if (p_belt_amount[i] == 0) {
                            // display text about the item being depleted.
                        }
                        if (was_used && p_belt_amount[i] > 0) {
                            p_belt_amount[i]--;
                            screen.printf("\x13\x04{} \x1F{:s} \x04Remaining", p_belt_amount[i], GetStringItemName(p_belt_equipped[i], U_CONSUMABLE));
                            // make this text more specific and maybe confined to 1 line
                        }
                    }
                }
                // BANDAGE
                if (p_cons_bandage_state[playerID] == 1) {
                    p_cons_bandage_state[playerID] = 0;
                    DrawCircle(p_x[playerID], p_y[playerID], 72, 16, IMAGE_GREEN_FLAME0, 0, ISCRIPT_NORMAL);
                    p_life_regen_consumables[playerID] += 25 * 256;
                    PlayWavAtPos("sound/Terran/Medic/TMedHeal.wav", p_x[playerID], p_y[playerID], 320);
                }
            }

            // WEAPON
            UpdateWeaponState(playerID);
            UpdateUtilityState(playerID);

            // EXP
            if (p_exp_buffer[playerID] > 0) {
                var exp_just_gained = p_exp_buffer[playerID];
                p_exp_total[playerID] += exp_just_gained;
                p_exp_current[playerID] += exp_just_gained;
                if (p_exp_current[playerID] >= p_exp_goal[playerID]) {
                    exp_just_gained = p_exp_current[playerID] - p_exp_goal[playerID];
                    LevelUp(playerID, p_cunit[playerID]);
                    p_exp_current[playerID] += exp_just_gained;
                }
                screen.printf("\x12\x1F+{} Exp \x04({} | {})\x09\x09", p_exp_buffer[playerID], p_exp_current[playerID], p_exp_goal[playerID]);
                PlayWAV("staredit/wav/gain_exp.ogg");
                p_exp_buffer[playerID] = 0;
            }
            if (Command(playerID, AtLeast, 1, U_EXPERIENCE)) {
                p_exp_lost_timer[playerID]--;
                setloc(L_MAIN, p_exp_x[playerID], p_exp_y[playerID]);
                CenterLoc(L_4X4, p_exp_x[playerID], p_exp_y[playerID]);
                if (HeroIsAt(L_4X4, playerID)) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_EXPL_BLUE_SMALL, 0, ISCRIPT_NORMAL);
                    RemoveUnit(U_EXPERIENCE, playerID);
                    p_exp_buffer[playerID] += p_exp_lost[playerID];
                    p_exp_lost[playerID] = 0;
                }
                if (experience_ping_timer == 0) {
                    MinimapPing(L_MAIN);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_HALLUC_DEATH1, 0, ISCRIPT_NORMAL);
                }
                if (p_exp_lost_timer[playerID] == 0) {
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_EXPL_BLUE_SMALL, 0, ISCRIPT_NORMAL);
                    RemoveUnit(U_EXPERIENCE, playerID);
                    DisplayText("\x13\x04Your dropped experience has vanished.");
                }
            }

            // TIME
            if (time_state_changed) {
                if (time_state == 0) {
                    PlaySong(0);
                }
                else if (time_state == 1) {
                    PlayWAV("staredit/wav/night_ambience_crickets.ogg");
                    PlayWAV("staredit/wav/night.ogg");
                }
            }

            // @bm DEATH
            if (!debug_enabled && total_time < 144) p_death_state[playerID] = 70;
            if (!IsAlive(playerID)) {
                p_death_state[playerID]++;
                if (debug_enabled) p_death_state[playerID] = 72;
                if (Deaths(playerID, AtLeast, 1, U_HERO[playerID])) {
                    SetDeaths(playerID, SetTo, 0, U_HERO[playerID]);
                    setloc(L_MAIN, p_x[playerID], p_y[playerID]);
                    CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_PLAGUE_CLOUD, 0, ISCRIPT_LONGFAST);
                    CenterView(L_MAIN);
                    DisplayText("\x13\x06- YOU DIED -");
                    RemoveUnit(U_EXPERIENCE, playerID);
                    if (p_exp_current[playerID] > 0) {
                        CreateUnitWithProperties(1, U_EXPERIENCE, L_MAIN, playerID, UnitProperty(invincible = true));
                        p_exp_lost[playerID] = p_exp_current[playerID];
                        p_exp_lost_timer[playerID] = 2880;
                        p_exp_current[playerID] = 0;
                        p_exp_x[playerID], p_exp_y[playerID] = p_x[playerID], p_y[playerID];
                        screen.printf("\x13\x04Lost \x1F{} \x04Experience!", p_exp_lost[playerID]);
                    }
                }
                if (p_death_state[playerID] >= 72) {
                    p_death_state[playerID] = 0;
                    SpawnHero(playerID);
                    // if (IsUserCP()) {
                    //     screen.printf("\x13\x1FHint: \x02{:s}", GetStringHint(p_current_death_hint));
                    //     p_current_death_hint++;
                    // }
                }
            }

            // HUD
            // display damage on weapon icon
            if (IsUserCP()) {
                const unit_damage_string = Db(512);
                sprintf(unit_damage_string, "\x04Unit Damage: \x02{}", p_damage[playerID]);
                const weapon_damage_string = Db(512);
                sprintf(weapon_damage_string, "\x04{:s} Damage: \x08{}", GetStringItemName(weapon_id[playerID], U_WEAPON), GetWeaponDamage(weapon_id[playerID], 0, playerID));
                settblf(300, 0, "{:s}\n{:s}\n\x0C", unit_damage_string, weapon_damage_string);
            }

            // @bm debug_enabled
            if (debug_enabled) {
                if (p_on_sigil[playerID]) {
                    HealPlayer(playerID, unit, 256);
                }
                debug_values[6] = p_x[playerID];
                debug_values[7] = p_y[playerID];
                eprintf("{} | {} | {} | {} | {} | {} | {} | {}", debug_values[0], debug_values[1], debug_values[2], debug_values[3], debug_values[4], debug_values[5], debug_values[6], debug_values[7]);
            }
        }

        // PLAYER 7 - MONSTERS
        if (playerID == $P7) {
            UpdateWeaponState(playerID);
        }
    EUDEndPlayerLoop();

    UpdateNPCs();
    UpdateUnitPhysics();

    if (world_interaction_visual_timer == 0) world_interaction_visual_timer = 24;
    else if (world_interaction_visual_timer > 0) world_interaction_visual_timer--;

    // FIELD PUZZLE
    if (world_interaction_visual_timer == 0) {
        for (var i = 0; i < 3; i++) {
            var player_close = 0;
            for (var p = 0; p < 6; p++) {
                if (p_on_world_interaction[p] == i + 1) player_close = 1;
            }
            if (player_close) {
                const x, y = world_interaction_x[i], world_interaction_y[i];
                const offset = 32;
                DrawCircle(x, y, 64, 20, IMAGE_NUKE_DOT, 17, ISCRIPT_NORMAL);
                if (field_puzzle_state[i] == 1) DrawLine(x, y, x, y - 64, 8, IMAGE_LONGBOLT_TRAIL, 17, ISCRIPT_NORMAL);
                else if (field_puzzle_state[i] == 2) DrawLine(x, y, x + 64, y, 8, IMAGE_LONGBOLT_TRAIL, 17, ISCRIPT_NORMAL);
                else if (field_puzzle_state[i] == 3) DrawLine(x, y, x, y + 64, 8, IMAGE_LONGBOLT_TRAIL, 17, ISCRIPT_NORMAL);
                else if (field_puzzle_state[i] == 4) DrawLine(x, y, x - 64, y, 8, IMAGE_LONGBOLT_TRAIL, 17, ISCRIPT_NORMAL);
            }
        }
    }
    if (field_puzzle_state[0] == field_puzzle_state_solution[0] && field_puzzle_state[1] == field_puzzle_state_solution[1] && field_puzzle_state[2] == field_puzzle_state_solution[2]) {
        const x, y = 2816, 2216;
        setloc(L_MAIN, x, y);
        CreateItemUnit(U_LIFEPICKUP, 0, L_MAIN, 1, 1);
        CreateImageSpriteAtLocation($P8, L_MAIN, IMAGE_HALLUC_DEATH1, 17, ISCRIPT_FAST);
        for (var i = 0; i < 3; i++) {
            field_puzzle_state[i] = 1000;
            DrawCircle(world_interaction_x[i], world_interaction_y[i], 256, 32, IMAGE_ZERG_AIR_DEATH_SMALL, 0, ISCRIPT_NORMAL);
            setloc(L_MAIN, world_interaction_x[i], world_interaction_y[i]);
            CreateUnitCircle(U_CHIMERA, $P7, L_MAIN, 320, 10);
            CenterLoc(L_10X10, world_interaction_x[i], world_interaction_y[i]);
            setloc(L_0X0, x, y);
            // Order(U_CHIMERA, $P7, L_10X10, Patrol, L_0X0);
            queue_pro_posx, queue_pro_posy = world_interaction_x[i], world_interaction_y[i];
            queue_pro_maxtime = 24;
            queue_pro_angle = GetAngle(world_interaction_x[i], world_interaction_y[i], x, y);
            queue_pro_velocity = 20;
            queue_pro_effect2 = U_SCOURGE;
            queue_pro_effect2_type = 1;
            CreateProjectile();
            ResetWorldInteractionIndex(i);
        }
        DisplayTextAll("\x13\x04You feel a strange release of energy.");
        for (var p = 0; p < 6; p++) {
            if (GetAreaAtPos(p_x[p], p_y[p]) == AREA_FIELD) PlayWAVCP("staredit/wav/solved.ogg", p);
        }
    }

    if (!debug_enabled) {
        if (total_time == 48) {
            ClearTextLines(0, 10);
            DisplayTextAllAt(5, "\x13\x06SPIRIT KNIGHTS");
        }
        if (total_time == 120) {
            ClearTextLines(0, 10);
            DisplayTextAllAt(5, "\x13\x04You wake up.");
        }
    }

    if (active_units_update == 0) active_units_update = 24;
    active_units_update -= 1;
    if (experience_ping_timer == 0) experience_ping_timer = 72;
    experience_ping_timer -= 1;
}